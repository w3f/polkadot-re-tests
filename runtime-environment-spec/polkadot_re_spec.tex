\documentclass{book}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,amssymb,calc,ifthen,expdlist,alltt,theorem,capt-of,makeidx}
\makeindex
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\assign}{:=}
\newcommand{\cdummy}{\cdot}
\newcommand{\nin}{\not\in}
\newcommand{\nobracket}{}
\newcommand{\nosymbol}{}
\newcommand{\tmcodeinline}[2][]{{\ttfamily{#2}}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmmathbf}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\tmname}[1]{\textsc{#1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmrsub}[1]{\ensuremath{_{\textrm{#1}}}}
\newcommand{\tmrsup}[1]{\textsuperscript{#1}}
\newcommand{\tmsamp}[1]{\textsf{#1}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmtextbf}[1]{{\bfseries{#1}}}
\newcommand{\tmtextit}[1]{{\itshape{#1}}}
\newcommand{\tmtextsc}[1]{{\scshape{#1}}}
\newcommand{\tmtextsf}[1]{{\sffamily{#1}}}
\newcommand{\tmtexttt}[1]{{\ttfamily{#1}}}
\newcommand{\tmtextup}[1]{{\upshape{#1}}}
\newcommand{\tmverbatim}[1]{{\ttfamily{#1}}}
\newenvironment{itemizedot}{\begin{itemize} \renewcommand{\labelitemi}{$\bullet$}\renewcommand{\labelitemii}{$\bullet$}\renewcommand{\labelitemiii}{$\bullet$}\renewcommand{\labelitemiv}{$\bullet$}}{\end{itemize}}
\newenvironment{itemizeminus}{\begin{itemize} \renewcommand{\labelitemi}{$-$}\renewcommand{\labelitemii}{$-$}\renewcommand{\labelitemiii}{$-$}\renewcommand{\labelitemiv}{$-$}}{\end{itemize}}
\newenvironment{theglossary}[1]{\begin{list}{}{\setlength{\labelwidth}{6.5em}\setlength{\leftmargin}{7em}\small} }{\end{list}}
\newenvironment{tmcode}[1][]{\begin{alltt} }{\end{alltt}}
\newenvironment{tmindent}{\begin{tmparmod}{1.5em}{0pt}{0pt}}{\end{tmparmod}}
\newenvironment{tmparmod}[3]{\begin{list}{}{\setlength{\topsep}{0pt}\setlength{\leftmargin}{#1}\setlength{\rightmargin}{#2}\setlength{\parindent}{#3}\setlength{\listparindent}{\parindent}\setlength{\itemindent}{\parindent}\setlength{\parsep}{\parskip}} \item[]}{\end{list}}
\newenvironment{tmparsep}[1]{\begingroup\setlength{\parskip}{#1}}{\endgroup}
\newcounter{tmcounter}
\newcommand{\custombinding}[1]{%
  \setcounter{tmcounter}{#1}%
  \addtocounter{tmcounter}{-1}%
  \refstepcounter{tmcounter}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newcommand{\tmfloatcontents}{}
\newlength{\tmfloatwidth}
\newcommand{\tmfloat}[5]{
  \renewcommand{\tmfloatcontents}{#4}
  \setlength{\tmfloatwidth}{\widthof{\tmfloatcontents}+1in}
  \ifthenelse{\equal{#2}{small}}
    {\setlength{\tmfloatwidth}{0.45\linewidth}}
    {\setlength{\tmfloatwidth}{\linewidth}}
  \begin{minipage}[#1]{\tmfloatwidth}
    \begin{center}
      \tmfloatcontents
      \captionof{#3}{#5}
    \end{center}
  \end{minipage}}
{\theorembodyfont{\rmfamily}\newtheorem{warning}{Warning}}
%%%%%%%%%% End TeXmacs macros

\providecommand{\cdummy}{{\cdot}}
\providecommand{\nobracket}{}
\providecommand{\nosymbol}{}
\providecommand{\tmem}[1]{\tmtextit{#1}}
\providecommand{\tmname}[1]{\tmtextsc{#1}}
\providecommand{\tmop}[1]{\ensuremath{\mathrm{#1}}}
\providecommand{\tmrsub}[1]{\tmrsub{\ensuremath{\mathrm{#1}}}}
\providecommand{\tmsamp}[1]{\tmtextsf{#1}}
\providecommand{\tmstrong}[1]{\tmtextbf{#1}}
\providecommand{\tmtextbf}[1]{\tmtextbf{#1}}
\providecommand{\tmtextit}[1]{\tmtextit{#1}}
\providecommand{\tmverbatim}[1]{\tmtexttt{#1}}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
%

\newcommand{\figuretext}{Snippet}
\newcommand{\figuretext}{Figure}

\begin{document}

\title{
  Polkadot Runtime Environment\\
  {\Large Protocol Specification}
}

\date{April 2, 2020}

\maketitle

{\tableofcontents}

\chapter{Background}

\section{Introduction}

Formally, Polkadot is a replicated sharded state machine designed to resolve
the scalability and interoperability among blockchains. In Polkadot
vocabulary, shards are called {\tmem{parachains}} and Polkadot {\tmem{relay
chain}} is part of the protocol ensuring global consensus among all the
parachains. The Polkadot relay chain protocol, henceforward called
{\tmem{Polkadot protocol}}, can itself be considered as a replicated state
machine on its own. As such, the protocol can be specified by identifying the
state machine and the replication strategy.

From a more technical point of view, the Polkadot protocol has been divided
into two parts, the {\tmem{Runtime}} and the {\tmem{Runtime environment}}
(RE). The Runtime comprises most of the state transition logic for the
Polkadot protocol and is designed and expected to be upgradable as part of the
state transition process. The Runtime environment consists of parts of the
protocol,\quad shared mostly among peer-to-peer decentralized
cryptographically-secured transaction systems, i.e. blockchains whose
consensus system is based on the proof-of-stake. The RE is planned to be
stable and static for the lifetime duration of the Polkadot protocol.

With the current document, we aim to specify the RE part of the Polkadot
protocol as a replicated state machine. After defining the basic terms in
Chapter 1, we proceed to specify the representation of a valid state of the
Protocol in Chapter \ref{chap-state-spec}. In Chapter
\ref{chap-state-transit}, we identify the protocol states, by explaining the
Polkadot state transition and discussing the detail based on which Polkadot RE
interacts with the state transition function, i.e. Runtime. Following, we
specify the input messages triggering the state transition and the system
behaviour. In Chapter \ref{chap-consensu}, we specify the consensus protocol,
which is responsible for keeping all the replica in the same state. Finally,
the initial state of the machine is identified and discussed in Appendix
\ref{sect-genesis-block}. A Polkadot RE implementation which conforms with
this part of the specification should successfully be able to sync its states
with the Polkadot network.

\section{Definitions and Conventions}\label{sect-defn-conv}

\begin{definition}
  \label{defn-state-machine}A {\tmstrong{Discrete State Machine (DSM)}} is a
  state transition system whose set of states and set of transitions are
  countable and admits a starting state. Formally, it is a tuple of
  \[  (\Sigma, S, s_0, \delta) \]
  where
  \begin{itemize}
    \item $\Sigma$ is the countable set of all possible transitions.
    
    \item $S$ is a countable set of all possible states.
    
    \item $s_0 \in S$ is the initial state.
    
    \item $\delta$ is the state-transition function, known as
    \label{defn-runtime}{\tmstrong{Runtime}} in the Polkadot vocabulary, such
    that
    \[ \delta : S \times \Sigma \rightarrow S \]
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-path-graph}A {\tmstrong{path graph}} or a {\tmstrong{path}} of
  $n$ nodes formally referred to as \label{autolab1}{\tmstrong{$P_n$}}, is a
  tree with two nodes of vertex degree 1 and the other n-2 nodes of vertex
  degree 2. Therefore, $P_n$ can be represented by sequences of $(v_1, \ldots,
  v_n)$ where $e_i = (v_i, v_{i + 1})$ for $1 \leqslant i \leqslant n - 1$ is
  the edge which connect $v_i$ and $v_{i + 1}$.
\end{definition}

\begin{definition}
  \label{defn-radix-tree}{\tmstrong{Radix-r tree}} is a variant of \ a trie in
  which:
  \begin{itemize}
    \item Every node has at most $r$ children where $r = 2^x$ for some $x$;
    
    \item Each node that is the only child of a parent, which does not
    represent a valid key is merged with its parent.
  \end{itemize}
\end{definition}

As a result, in a radix tree, any path whose interior vertices all have only
one child and does not represent a valid key in the data set, is compressed
into a single edge. This improves space efficiency when the key space is
sparse.

\begin{definition}
  By a {\tmstrong{sequences of bytes}} or a {\tmstrong{byte array}}, $b$, of
  length $n$, we refer to
  \[ b \assign (b_0, b_1, ..., b_{n - 1})  \text{such that } 0 \leqslant b_i
     \leqslant 255 \]
  We define \label{autolab2}$\mathbb{B}_n$ to be the {\tmstrong{set of all
  byte arrays of length $n$}}. Furthermore, we define:
  \[ \mathbb{B} \assign \bigcup^{\infty}_{i = 0} \mathbb{B}_i \]
\end{definition}

\begin{notation}
  We represent the concatenation of byte arrays $a \assign (a_0, \ldots, a_n)$
  and $b \assign (b_0, \ldots, b_m)$ by:
  \[ a || b \assign (a_0, \ldots, a_n, b_0, \ldots, b_m) \]
\end{notation}

\begin{definition}
  \label{defn-bit-rep}For a given byte $b$ the {\tmstrong{bitwise
  representation}} of $b$ is defined as
  \[ b \assign b^7 \ldots b^0 \]
  where
  \[ b = 2^0 b^0 + 2^1 b^1 + \cdots + 2^7 b^7 \]
\end{definition}

\begin{definition}
  \label{defn-little-endian}By \tmverbatim{}the {\tmstrong{little-endian}}
  representation of a non-negative integer, \label{autolab3}I, represented as
  \[ I = (B_n \ldots B_0)_{256} \]
  in base 256, we refer to a byte array \label{autolab4}$B = (b_0, b_1,
  \ldots, b_n)$ such that
  \[ b_i \assign B_i \]
  Accordingly, define the function \label{autolab5}$\tmop{Enc}_{\tmop{LE}}$:
  \[ \begin{array}{llll}
       \tmop{Enc}_{\tmop{LE}} : & \mathbb{Z}^+ & \rightarrow & \mathbb{B}\\
       & (B_n \ldots B_0)_{256} & \mapsto & (B_{0,} B_1, \ldots_{}, B_n)
     \end{array} \]
  
\end{definition}

\begin{definition}
  By {\tmname{{\tmstrong{\tmverbatim{UINT32}}}}} we refer to a non-negative
  integer stored in a byte array of length 4 using little-endian encoding
  format.
\end{definition}

\begin{definition}
  A \label{autolab6}{\tmstrong{blockchain}} $C$ is a directed path graph. Each
  node of the graph is called \label{autolab7}{\tmstrong{Block}} and indicated
  by {\tmstrong{$B$}}. The unique sink of $C$ is called
  \label{autolab8}{\tmstrong{Genesis Block}}, and the source is called the
  \label{autolab9}{\tmstrong{Head}} of C. For any vertex $(B_1, B_2)$ where
  $B_1 \rightarrow B_2$ we say $B_2$ is the
  \label{autolab10}{\tmstrong{parent}} of $B_1$ and we indicate it by
  \[ B_2 \assign P (B_1) \]
\end{definition}

\begin{definition}
  \label{defn-unix-time}By {\tmstrong{UNIX time}}, we refer to the unsigned,
  little-endian encoded 64-bit integer which stores the number of
  {\tmstrong{milliseconds}} that have elapsed since the Unix epoch, that is
  the time 00:00:00 UTC on 1 January 1970, minus leap seconds. Leap seconds
  are ignored, and every day is treated as if it contained exactly 86400
  seconds.
\end{definition}

\subsection{Block Tree}

In the course of formation of a (distributed) blockchain, it is possible that
the chain forks into multiple subchains in various block positions. We refer
to this structure as a {\tmem{block tree:}}

\begin{definition}
  \label{defn-block-tree}The \label{autolab11}{\tmstrong{block tree}} of a
  blockchain, denoted by $\tmop{BT}$ is the union of all different versions of
  the blockchain observed by all the nodes in the system such as every such
  block is a node in the graph and $B_1$ is connected to $B_2$ if $B_1$ is a
  parent of $B_2$.
\end{definition}

When a block in the block tree gets finalized, there is an opportunity to
prune the block tree to free up resources into branches of blocks that do not
contain all of the finalized blocks or those that can never be finalized in
the blockchain. For a definition of finality, see Section \ref{sect-finality}.

\begin{definition}
  \label{defn-pruned-tree}By \label{autolab12}{\tmstrong{Pruned Block Tree}},
  denoted by $\tmop{PBT}$, we refer to a subtree of the block tree obtained by
  eliminating all branches which do not contain the most recent finalized
  blocks, as defined in Definition \ref{defn-finalized-block}. By
  \label{autolab13}{\tmstrong{pruning}}, we refer to the procedure of
  $\tmop{BT} \leftarrow \tmop{PBT}$. When there is no risk of ambiguity and is
  safe to prune BT, we use $\tmop{BT}$ to refer to $\tmop{PBT}$.
\end{definition}

Definition \ref{defn-chain-subchain} gives the means to highlight various
branches of the block tree.

\begin{definition}
  \label{defn-chain-subchain}Let \label{autolab14}$G$ be the root of the block
  tree and $B$ be one of its nodes. By
  \label{autolab15}{\tmname{{\tmstrong{Chain($B$)}},}} we refer to the path
  graph from $G$ to $B$ in (P)$\tmop{BT}$. Conversely, for a chain
  $C$={\tmname{Chain(B)}}, we define \label{autolab16}{\tmstrong{the head of
  $C$}} to be $B$, formally noted as $B \assign${\tmname{Head($C$)}}. We
  define \label{autolab17}$| C |$, the length of $C$as a path graph. If $B'$
  is another node on {\tmname{Chain($B$)}}, then by
  \label{autolab18}{\tmname{SubChain($B', B$)}} we refer to the subgraph of
  {\tmname{Chain($B$)}} path graph which contains both $B$ and $B'$ and by
  {\tmname{\textbar SubChain($B', B$)\textbar}} we refer to its length.
  Accordingly, \label{autolab19}$\mathbb{C}_{B'} ((P) \tmop{BT})$ is the set
  of all subchains of $(P) \tmop{BT}$ rooted at $B'$. The set of all chains of
  $(P) \tmop{BT}$, $\mathbb{C}_G ((P) \tmop{BT})$ is denoted by
  $\mathbb{C}$((P)BT) or simply \label{autolab20}$\mathbb{C}$, for the sake of
  brevity.
\end{definition}

\begin{definition}
  \label{defn-longest-chain}We define the following complete order over
  $\mathbb{C}$ such that for $C_1, C_2 \in \mathbb{C}$ if $| C_1 | \neq | C_2
  |$ we say $C_1 > C_2$ if and only if $| C_1 | > | C_2 |$.
  
  If $| C_1 | = | C_2 |$ we say $C_1 > C_2$ if and only if the block arrival
  time of $\tmop{Head} (C_1)_{}$ is less than the block arrival time of
  $\tmop{Head} (C_2)$ as defined in Definition \ref{defn-block-time}. We
  define the
  \label{autolab21}{\tmstrong{{\tmname{Longest-Chain($\tmop{BT}$)}}}} to be
  the maximum chain given by this order.
\end{definition}

\begin{definition}
  \label{autolab22}{\tmname{Longest-Path($\tmop{BT}$)}} returns the path graph
  of $(P) \tmop{BT}$ which is the longest among all paths in $(P) \tmop{BT}$
  and has the earliest block arrival time as defined in Definition
  \ref{defn-block-time}. \label{autolab23}
  {\tmname{Deepest-Leaf($\tmop{BT}$)}} returns the head of
  {\tmname{Longest-Path($\tmop{BT}$)}} chain.
\end{definition}

Because every block in the blockchain contains a reference to its parent, it
is easy to see that the block tree is de facto a tree. A block tree naturally
imposes partial order relationships on the blocks as follows:

\begin{definition}
  We say {\tmstrong{B is descendant of $B'$}}, formally noted as {\tmstrong{$B
  > B'$}} if $B$ is a descendant of $B'$ in the block tree.
\end{definition}

\chapter{State Specification}\label{chap-state-spec}

\section{State Storage and Storage Trie}\label{sect-state-storage}

For storing the state of the system, Polkadot RE implements a hash table
storage where the keys are used to access each data entry. There is no
assumption either on the size of the key nor on the size of the data stored
under them, besides the fact that they are byte arrays with specific upper
limits on their length. The limit is imposed by the encoding algorithms to
store the key and the value in the storage trie.

\

The state storage requires a mechanism to identify any changes made by each
block, in case non-finalized blocks have to be reverted or a Changes Trie as
described in section \ref{defn-changes-trie} needs to be created. This
specification does not dictate how that mechanism must be implemented.

\subsection{Accessing System Storage }

Polkadot RE implements various functions to facilitate access to the system
storage for the Runtime. See Section \ref{sect-entries-into-runtime} for a an
explaination of those functions. Here we formalize the access to the storage
when it is being directly accessed by Polkadot RE (in contrast to Polkadot
runtime).

\begin{definition}
  \label{defn-stored-value}The \label{autolab24}{\tmstrong{StoredValue}}
  function retrieves the value stored under a specific key in the state
  storage and is formally defined as :
  \[ \begin{array}{cc}
       \tmop{StoredValue} : & \mathcal{K} \rightarrow \mathcal{V}\\
       & k \mapsto \left\{ \begin{array}{cc}
         v & \text{if (k,v) exists in state storage}\\
         \phi & \tmop{otherwise}
       \end{array} \right.
     \end{array} \]
  where $\mathcal{K} \subset \mathbb{B}$ and $\mathcal{V} \subset \mathbb{B}$
  are respectively the set of all keys and values stored in the state storage.
  
  \ 
\end{definition}

\subsection{The General Tree Structure}

In order to ensure the integrity of the state of the system, the stored data
needs to be re-arranged and hashed in a {\tmem{modified Merkle Patricia
Tree}}, which hereafter we refer to as the {\tmem{{\tmstrong{Trie}}}}. This
rearrangment is necessary to be able to compute the Merkle hash of the whole
or part of the state storage, consistently and efficiently at any given time.

The Trie is used to compute the {\tmem{state root}}, $H_r$, (see Definition
\ref{defn-block-header}), whose purpose is to authenticate the validity of the
state database. Thus, Polkadot RE follows a rigorous encoding algorithm to
compute the values stored in the trie nodes to ensure that the computed Merkle
hash, $H_r$, matches across the Polkadot RE implementations.

The Trie is a {\tmem{radix-16}} tree as defined in Definition
\ref{defn-radix-tree}. Each key value identifies a unique node in the tree.
However, a node in a tree might or might not be associated with a key in the
storage.

When traversing the Trie to a specific node, its key can be reconstructed by
concatenating the subsequences of the key which are stored either explicitly
in the nodes on the path or implicitly in their position as a child of their
parent.

To identify the node corresponding to a key value, $k$, first we need to
encode $k$ in a consistent with the Trie structure way. Because each node in
the trie has at most 16 children, we represent the key as a sequence of 4-bit
nibbles:

\begin{definition}
  For the purpose of labeling the branches of the Trie, the key $k$ is encoded
  to $k_{\tmop{enc}}$ using KeyEncode functions:
  \begin{equation}
    k_{\tmop{enc}} \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
    \assign \tmop{KeyEncode} (k) \label{key-encode-in-trie}
  \end{equation}
  such that:
  \[ \tmop{KeyEncode} (k) : \left\{ \begin{array}{lll}
       \mathbb{B}^{\nosymbol} & \rightarrow & \tmop{Nibbles}^4\\
       k \assign (b_1, \ldots, b_n) \assign & \mapsto & (b^1_1, b^2_1, b_2^1,
       b^2_2, \ldots, b^1_n, b^2_n)\\
       &  & \assign (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{2 n}})
     \end{array} \right. \]
  where $\tmop{Nibble}^4$ is the set of all nibbles of 4-bit arrays and
  $b^1_i$ and $b^2_i$ are 4-bit nibbles, which are the big endian
  representations of $b_i$:
  \[ (b^1_i, b^2_i) \assign (b_i / 16, b_i \tmop{mod} 16) \]
  , where mod is the remainder and / is the integer division operators.
\end{definition}

By looking at $k_{\tmop{enc}}$ as a sequence of nibbles, one can walk the
radix tree to reach the node identifying the storage value of $k$.

\subsection{Trie Structure}\label{sect-state-storage-trie-structure}

In this subsection, we specify the structure of the nodes in the Trie as well
as the Trie structure:

\begin{notation}
  We refer to the {\tmstrong{set of the nodes of Polkadot state trie}} by
  $\mathcal{N}.$ By $N \in \mathcal{N}$ to refer to an individual node in the
  trie.
\end{notation}

\begin{definition}
  \label{defn-nodetype}The State Trie is a radix-16 tree. Each Node in the
  Trie is identified with a unique key $k_N$ such that:
  \begin{itemizeminus}
    \item $k_N$ is the shared prefix of the key of all the descendants of $N$
    in the Trie.
  \end{itemizeminus}
  and, at least one of the following statements holds:
  \begin{itemizeminus}
    \item $(k_N, v)$ corresponds to an existing entry in the State Storage.
    
    \item N has more than one child.
  \end{itemizeminus}
  \tmverbatim{}Conversely, if $(k, v)$ is an entry in the State Trie then
  there is a node $N \in \mathcal{N}$ such that $k_N$=k.
\end{definition}

\begin{notation}
  A {\tmstrong{branch}} node is a node which has one child or more. A branch
  node can have at most 16 children. A {\tmstrong{leaf}} node is a childless
  node. Accordingly:
  \[ \begin{array}{c}
       \mathcal{N}_b \assign \left\{ N \in \mathcal{N}|N \text{is a branch
       node} \right\}\\
       \mathcal{N}_l \assign \left\{ N \in \mathcal{N}|N \text{is a leaf node}
       \right\}
     \end{array} \]
\end{notation}

For each Node, part of $k_N$ is built while the trie is traversed from root to
$N$ part of $k_N$ is stored in $N$ as formalized in Definition
\ref{defn-node-key}.

\begin{definition}
  \label{defn-node-key}For any $N \in \mathcal{N}$, its key $k_N$ is divided
  into an {\tmstrong{aggregated prefix key}},
  {\tmstrong{$\tmop{pk}_N^{\tmop{Agr}}$}}, aggregated by Algorithm
  \ref{algo-aggregate-key} and a {\tmstrong{partial key}},
  {\tmstrong{$\tmop{pk}_N$}} of length $0 \leqslant l_{\tmop{pk}_N} \leqslant
  65535$ in nibbles such that:
  \[ \tmop{pk}_N \assign (k_{\tmop{enc}_i}, \ldots, k_{\tmop{enc}_{i +
     l_{\tmop{pk}_N}}}) \]
  where $\tmop{pk}_N$ is a suffix subsequence of $k_N$; $i$ is the length of
  $\tmop{pk}_N^{\tmop{Agr}}$ in nibbles and so we have:
  \[ \tmop{KeyEncode} (k_N) = \tmop{pk}_N^{\tmop{Agr}} | | \tmop{pk}_N =
     (k_{\tmop{enc}_1}, \ldots, k_{\tmop{enc}_{i - 1}}, k_{\tmop{enc}_i},
     k_{\tmop{enc}_{i + l_{\tmop{pk}_N}}}) \]
\end{definition}

Part of $\tmop{pk}_N^{\tmop{Agr}}$ is explicitly stored in $N$'s ancestors.
Additionally, for each ancestor, a single nibble is implicitly derived while
traversing from the ancestor to its child included in the traversal path using
the $\tmop{Index}_N$ function defined in Definition \ref{defn-index-function}.

\begin{definition}
  \label{defn-index-function}For $N \in \mathcal{N}_b$ and $N_c$ child of N,
  we define {\tmstrong{$\tmop{Index}_N$}} function as:
  \[ \begin{array}{cc}
       \tmop{Index}_N : & \left\{ N_c \in \mathcal{N}|N_c  \text{is a child of
       N} \right\} \rightarrow \tmop{Nibbles}^4_1\\
       & N_c \mapsto i_{}
     \end{array} \]
  such that
  \[ k_{N_c} = k_N | | i | | \tmop{pk}_{N_c} \]
\end{definition}

Assuming that $P_N$ is the path (see Definition \ref{defn-path-graph}) from
the Trie root to node $N$, Algorithm \ref{algo-aggregate-key} rigorously
demonstrates how to build $\tmop{pk}^{\tmop{Agr}}_N$ while traversing $P_N$.

\custombinding{1}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{1}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-aggregate-key}{\tmname{Aggregate-Key}}$(P_N : =
      (\tmop{TrieRoot} = N_1, \ldots, N_j = N))$
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\begin{definition}
  \label{defn-node-value}A node $N \in \mathcal{N}$ stores the {\tmstrong{node
  value}}, {\tmstrong{$v_N$}}, which consists of the following concatenated
  data:
  \[ \begin{array}{|l|l|l|}
       \hline
       \tmop{Node} \tmop{Header} & \tmop{Partial} \tmop{key} & \tmop{Node}
       \tmop{Subvalue}\\
       \hline
     \end{array} \]
  Formally noted as:
  \[ v_N \assign \tmop{Head}_N | | \tmop{Enc}_{\tmop{HE}} (\tmop{pk}_N) | |
     \tmop{sv}_N \]
  where $\tmop{Head}_N$, $\tmop{pk}_N$, $\tmop{Enc}_{\tmop{nibbles}}$ and
  $\tmop{sv}_N$ are defined in Definitions \ref{defn-node-header},
  \ref{defn-node-key}, \ref{defn-hex-encoding} and \ref{defn-node-subvalue},
  respectively.
\end{definition}

\begin{definition}
  \label{defn-node-header}The {\tmstrong{node header}} of node $N$,
  $\tmop{Head}_N$, consists of $l + 1 \geqslant 1$ bytes $\tmop{Head}_{N, 1},
  \ldots, \tmop{Head}_{N, l + 1}$ such that:
  
  
  \[ \begin{array}{ll}
       \hline
       \tmop{Node} \tmop{Type} & \tmop{pk} \tmop{length}\\
       \hline
       \tmop{Head}_{N, 1}^{6 - 7}_{} & \tmop{Head}_{N, 1}^{0 - 5}_{}
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} 1\\
       \hline
       \tmop{Head}_{N, 2}\\
       \hline
     \end{array}  \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{key} \tmop{length} \tmop{extra} \tmop{byte} 2\\
       \hline
       \ldots .\\
       \hline
     \end{array} \ldots \begin{array}{|l|}
       \hline
       \tmop{pk} \tmop{length} \tmop{extra} \tmop{byte} l\\
       \hline
       \tmop{Head}_{N, l + 1}^{}_{}\\
       \hline
     \end{array} \]
  
  
  In which $\tmop{Head}_{N, 1}^{6 - 7}_{}$, the two most significant bits of
  the first byte of $\tmop{Head}_N$ are determined as follows:
  \[ \tmop{Head}_{N, 1}^{6 - 7}_{} \assign \left\{ \begin{array}{ll}
       00 & \tmop{Special} \tmop{case}\\
       01 & \tmop{Leaf} \tmop{Node}\\
       10 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \nin \mathcal{K}\\
       11 & \tmop{Branch} \tmop{Node} \tmop{with} k_N \in \mathcal{K}
     \end{array} \right. \]
  where $\mathcal{K}$ is defined in Definition \ref{defn-stored-value}.
  
  $\tmop{Head}_{N, 1}^{0 - 5}_{}$, the 6 least significant bits of the first
  byte of $\tmop{Head}_N$ are defined to be:
  \[ \tmop{Head}_{N, 1}^{0 - 5}_{} \assign \left\{ \begin{array}{ll}
       \| \tmop{pk}_N \|_{\tmop{nib}} & \| \tmop{pk}_N \|_{\tmop{nib}} < 63\\
       63 & \| \tmop{pk}_N \|_{\tmop{nib}} \geqslant 63
     \end{array} \right. \]
  In which {\tmstrong{$\| \tmop{pk}_N \|_{\tmop{nib}}$}} is the length of
  $\tmop{pk}_N $ in number nibbles. $\tmop{Head}_{N, 2}, \ldots,
  \tmop{Head}_{N, l + 1}$ bytes are determined by Algorithm
  \ref{algo-pk-length}.
\end{definition}

\custombinding{2}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{2}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-pk-length}{\tmname{Partial-Key-Length-Encoding$(\tmop{Head}_{N,
      1}^{6 - 7}_{}, \tmop{pk}_N)$}}
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\subsection{Merkle Proof}\label{sect-merkl-proof}

To prove the consistency of the state storage across the network and its
modifications both efficiently and effectively, the Trie implements a Merkle
tree structure. The hash value corresponding to each node needs to be computed
rigorously to make the inter-implementation data integrity possible.

The Merkle value of each node should depend on the Merkle value of all its
children as well as on its corresponding data in the state storage. This
recursive dependancy is encompassed into the subvalue part of the node value
which recursively depends on the Merkle value of its children.

We use the auxilary function introduced in Definition
\ref{defn-children-bitmap} to encode and decode information stored in a branch
node.

\begin{definition}
  \label{defn-children-bitmap}Suppose $N_b, N_c \in \mathcal{N}$ and $N_c$ is
  a child of $N_b$. We define where bit $b_i : = 1$ if $N$ has a child with
  partial key $i$, therefore we define {\tmstrong{ChildrenBitmap}} functions
  as follows:
  \[ \begin{array}{cc}
       \tmop{ChildrenBitmap} : & \mathcal{N}_b \rightarrow \mathbb{B}_2\\
       & N \mapsto (b_{15}, \ldots, b_8, b_7, \ldots b_0)_2
     \end{array} \]
  where
  \[ b_i \assign \left\{ \begin{array}{cc}
       1 & \exists N_c \in \mathcal{N}: k_{N_c} = k_{N_b} | | i | |
       \tmop{pk}_{N_c}\\
       0 & \text{otherwise}
     \end{array} \right. \]
\end{definition}

\tmverbatim{}

\begin{definition}
  \label{defn-node-subvalue}For a given node $N$, the {\tmstrong{subvalue}} of
  $N$, formally referred to as $\tmop{sv}_N$, is determined as follows: in a
  case which:
  \begin{itemize}
    \[ \begin{array}{l}
         \tmop{sv}_N \assign\\
         \left\{ \begin{array}{cc}
           \tmop{Enc}_{\tmop{SC}} (\tmop{StoredValue} (k_N)) & \text{N is a
           leaf node}\\
           \nobracket \tmop{ChildrenBitmap} (N)\| \tmop{Enc}_{\tmop{SC}} (H
           (N_{C_1})) \ldots \tmop{Enc}_{\tmop{SC}} (H (N_{C_n})) | |
           \tmop{Enc}_{\tmop{SC}} (\tmop{StoredValue} (k_N))  & \text{N is a
           branch node}
         \end{array} \right.
       \end{array} \]
  \end{itemize}
\end{definition}

Where $N_{C_1} \ldots N_{C_n}$ with $n \leqslant 16$ are the children nodes of
the branch node $N$ and Enc\tmrsub{SC}, $\tmop{StoredValue}$, $H$, and
$\tmop{ChildrenBitmap} (N)$ are defined in Definitions \ref{sect-scale-codec},
\ref{defn-stored-value}, \ref{defn-merkle-value} and
\ref{defn-children-bitmap} respectively.

\

The Trie deviates from a traditional Merkle tree where node value, $v_N$ (see
Definition \ref{defn-node-value}) is presented instead of its hash if it
occupies less space than its hash.

\begin{definition}
  \label{defn-merkle-value}For a given node $N$, the {\tmstrong{Merkle value}}
  of $N$, denoted by $H (N)$ is defined as follows:
  \[ \begin{array}{ll}
       & H : \mathbb{B} \rightarrow \cup_{i \rightarrow 0}^{32}
       \mathbb{B}_{32}\\
       & H (N) : \left\{ \begin{array}{lcl}
         v_N &  & \|v_N \|< 32 \infixand N \neq R\\
         \tmop{Blake} 2 b (v_N) &  & \|v_N \| \geqslant 32 \infixor N = R
       \end{array} \right.
     \end{array} \]
  Where $v_N$ is the node value of $N$ defined in Definition
  \ref{defn-node-value} and $R$ is the root of the Trie. The {\tmstrong{Merkle
  hash}} of the Trie is defined to be $H (R)$.
\end{definition}

\subsection{Changes Trie}\label{defn-changes-trie}

Polkadot focuses on light client friendliness and therefore implements
functionality which allows identifying changes in the blockchain without
requiring to search through the entire chain. The {\tmstrong{Changes Trie}} is
a datastructure maintained by the Polkadot node which tracks storage changes
created by each block. The primary method of generating the Changes Trie is by
calling the \tmverbatim{ext\_storage\_changes\_root} Host API as described in
section \ref{sect-ext-storage-changes-root}. The Polkadot Host requires a
mechanism to identify the changes created by a block, as mentioned in section
\ref{sect-state-storage}.

\

The Changes Trie tracks changes in three different types of mappings (or
search indices) which are differentiated by their key as defined in table
\ref{table-changes-trie-key-types}. inside the trie. While the overall
structure of each keys is almost identical, each mapping has it own prefix and
could therefore be considered a \tmtextit{varying datatype} (as defined in
\ref{defn-varrying-data-type}). In contrast to a \tmtextit{varying datatype}
however, the type identifiers do not describes the type of the value following
the it, but of the value contained in the trie itself. The format and use of
these values are specified in more detail in their corresponding definitions
\ref{defn-storage-key-to-extrinsics}, \ref{defn-storage-key-to-blocks} and
\ref{defn-storage-key-to-child-tries} respectivly.{\hspace*{\fill}}

\begin{table}[h]
  \begin{tabular}{lll}
    \hline
    {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Followed by}}\\
    \hline
    1 & Mapping between storage key and extrinsics
    (\ref{defn-storage-key-to-extrinsics}) & {\tmem{KeyIndex}}
    (\ref{defn-key-index})\\
    \hline
    2 & Mapping between storage key and blocks
    (\ref{defn-storage-key-to-blocks}) & {\tmem{KeyIndex}}
    (\ref{defn-key-index})\\
    \hline
    3 & Mapping between storage key and child changes Trie
    (\ref{defn-storage-key-to-child-tries}) & {\tmem{KeyIndex}}
    (\ref{defn-key-index})\\
    \hline
  \end{tabular}
  
  \
  \caption{\label{table-changes-trie-key-types}Possible types of keys of
  mappings in the Changes Trie}
\end{table}

{\tmstrong{Note}}: Unlike the default encoding for varying data types, this
structure starts its indexing at \tmverbatim{1}.

\begin{definition}
  \label{defn-key-index}The {\tmstrong{Key Index}} is a tuple containing the
  following information:
  
  \begin{table}[h]
    \begin{tabular}{lll}
      \hline
      {\tmstrong{Name}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
      \hline
      Block & Block number at which this key has been inserted in the trie &
      Unsigned 32-bit integer\\
      \hline
      Key & The changed key & Byte array\\
      \hline
    \end{tabular}
    \caption{Key structure inserted in the Changes Trie}
  \end{table}
\end{definition}

\begin{definition}
  \label{defn-storage-key-to-extrinsics}The {\tmstrong{storage key to
  extrinsics mappings}} track any changes which occure in an individual block.
  Its value is a SCALE encoded array containing the indices of the extrinsics
  that caused any changes to its key. The indices are unsigned 32-bit integers
  and their values is based on the order in which each extrinsic is appears in
  the block. Additionally, a separate Changes Trie is created for each child
  storage where changes occured.
  
  Keys that were modified outside of extrinsics, such as changes made by the
  Runtime directly, have a \tmverbatim{0xffffffff} value as its indice.
  
  The Changes Trie is generated when the Runtime calls
  \tmverbatim{ext\_storage\_changes\_root} as described in section
  \ref{sect-ext-storage-changes-root}.
\end{definition}

\begin{definition}
  \label{defn-storage-key-to-blocks}The {\tmstrong{storage key to blocks
  mappings}} track any changes which occured in a certain range of blocks. Its
  value is a SCALE encoded array containing block numbers where extrinsics
  caused any changes to its key. The block numbers are represented as unsigned
  32-bit integers.
  
  The Changes Trie is generated when the Runtime calls
  \tmverbatim{ext\_storage\_changes\_root} as described in section
  \ref{sect-ext-storage-changes-root}, but unlike the other mappings, they are
  not generated on each block. The Runtime sets the key
  \tmverbatim{:changes\_trie} in storage with its value being a tuple of two
  32-bit integers:
  \begin{itemizedot}
    \item \tmverbatim{digest\_interval} - The interval (in blocks) at which
    block mappings are created. Block mappings are not created when this is
    less or equal to \tmverbatim{1}.
    
    \item \tmverbatim{digest\_levels} - Maximal number of ``levels'' in the
    hierarchy. \tmverbatim{0} means that block mappings are not created at
    all. \tmverbatim{1} means only the regular \tmverbatim{digest\_interval}
    block mappings are created. Any other level means that the block mappings
    are created every \tmverbatim{$\tmop{digest} \_
    \tmop{interval}^{\tmop{level}}$} block for each level in \tmverbatim{1} to
    \tmverbatim{digest\_levels}.
  \end{itemizedot}
  The Polkadot node must track the interval and levels, verify if conditions
  apply and then generate those mappings when the Runtime calls
  \tmverbatim{ext\_storage\_changes\_root}. The range spans from the last
  block (where this kind of mappings were created) + 1 to the current block.
  
  Whenever the interval and level stored in \tmverbatim{:changes\_trie}
  changes the current interval is reset and an new digest according to the
  changed parameters is started.
\end{definition}

\begin{definition}
  \label{defn-storage-key-to-child-tries}The {\tmstrong{storage key to child
  changes tries mappings}} track any storage keys from child storages and
  their corresponding Child Changes Trie. As described in Definition
  \ref{defn-storage-key-to-extrinsics}, changes inside child storages are
  inserted into their own Trie. The changed key is inserted into the main
  Trie, where its value is the Merkle proof as desribed in section
  \ref{sect-merkl-proof} of the corresponding Child Storage Trie, which stores
  the mappings between the storage key and extrinsics.
\end{definition}

The Changes Trie itself is not part of the block, but a separately maintained
database by the Polkadot node. The Merkle proof of the Changes Trie must be
inlcuded in the block digest as described in Definition \ref{defn-digest} and
gets calculated as described in section \ref{sect-merkl-proof}. The root
calculation uses entries of a per-block basis (including block mappings when
conditions apply on that block), not the whole changes spanning multiple
blocks.\chapter{State Transition}\label{chap-state-transit}

Like any transaction-based transition system, Polkadot state changes via
executing an ordered set of instructions. These instructions are known as
{\tmem{extrinsics}}. In Polkadot, the execution logic of the state-transition
function is encapsulated in Runtime as defined in Definition
\ref{defn-state-machine}. Runtime is presented as a Wasm blob in order to be
easily upgradable. Nonetheless, the Polk{\nobreak}adot Runtime Environment
needs to be in constant interaction with Runtime. The detail of such
interaction is further described in Section \ref{sect-entries-into-runtime}.

In Section \ref{sect-extrinsics}, we specify the procedure of the process
where the extrinsics are submitted, pre-processed and validated by Runtime and
queued to be applied to the current state.

Polkadot, as with most prominent distributed ledger systems that make state
replication feasible, journals and batches a series of extrinsics together in
a structure known as a {\tmem{block}} before propagating to the other nodes.
The specification of the Polkadot block as well as the process of verifying
its validity are both explained in Section \ref{sect-state-replication}.

\section{Interactions with Runtime}\label{sect-entries-into-runtime}

Runtime as defined in Definition \ref{defn-runtime} is the code implementing
the logic of the chain. This code is decoupled from the Polkadot RE to make
the Runtime easily upgradable without the need to upgrade the Polkadot RE
itself. The general procedure to interact with Runtime is described in
Algorithm \ref{algo-runtime-interaction}.

\custombinding{3}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{3}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-runtime-interaction}{\tmname{Interact-With-Runtime}}($F$:
      the runtime entry,
      
      $H_b (B)$: Block hash indicating the state at the end of $B$,
      
      $A_1, A_2, \ldots, A_n$: arguments to be passed to the runtime entry)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

In this section, we describe the details upon which the Polkadot RE is
interacting with the Runtime. In particular, {\tmname{Set-State-At}} and
{\tmname{Call-Runtime-Entry}} procedures called in Algorithm
\ref{algo-runtime-interaction} are explained in Notation
\ref{nota-call-into-runtime} and Definition \ref{defn-set-state-at}
respectively. $R_B$ is the Runtime code loaded from $\mathcal{S}_B$, as
described in Notation \ref{nota-runtime-code-at-state}, and
$\mathcal{R}\mathcal{E}_B$ is the Polkadot RE API, as described in Notation
\ref{nota-re-api-at-state}.

\subsection{Loading the Runtime Code \ \ }\label{sect-loading-runtime-code}

Polkadot RE expects to receive the code for the Runtime of the chain as a
compiled WebAssembly (Wasm) Blob. The current runtime is stored in the state
database under the key represented as a byte array:
\[ b \assign \text{3A,63,6F,64,65} \]
which is the byte array of ASCII representation of string ``:code'' (see
Section \ref{sect-genesis-block}). For any call to the Runtime, Polkadot RE
makes sure that it has the Runtime corresponding to the state in which the
entry has been called. This is, in part, because the calls to Runtime have
potentially the ability to change the Runtime code and hence Runtime code is
state sensitive. Accordingly, we introduce the following notation to refer to
the Runtime code at a specific state:

\begin{notation}
  \label{nota-runtime-code-at-state}By $R_B$, we refer to the Runtime code
  stored in the state storage whose state is set at the end of the execution
  of block $B$.
\end{notation}

The initial runtime code of the chain is embedded as an extrinsics into the
chain initialization JSON file (representing the genesis state) and is
submitted to Polkadot RE (see Section \ref{sect-genesis-block}).

Subsequent calls to the runtime have the ability to, in turn, call the storage
API (see Section \ref{sect-re-api}) to insert a new Wasm blob into runtime
storage slot to upgrade the runtime.

\subsection{Code Executor}

Polkadot RE provides a Wasm Virtual Machine (VM) to run the Runtime. The Wasm
VM exposes the Polkadot RE API to the Runtime, which, on its turn, executes a
call to the Runtime entries stored in the Wasm module. This part of the
Runtime environment is referred to as the {\tmem{{\tmstrong{Executor}}.}}

Definition \ref{nota-call-into-runtime} introduces the notation for calling
the runtime entry which is used whenever an algorithm of Polkadot RE needs to
access the runtime.

\begin{notation}
  \label{nota-call-into-runtime} By
  \[ \text{{\tmname{Call-Runtime-Entry}}} \left( R, \mathcal{R}\mathcal{E},
     \text{\tmverbatim{Runtime-Entry}}, A, A_{\tmop{len}} \right) \]
  we refer to the task using the executor to invoke the
  \tmverbatim{Runtime-Entry} while passing an $A_1, \ldots, A_n$ argument to
  it and using the encoding described in Section
  \ref{sect-runtime-send-args-to-runtime-enteries}.
\end{notation}

In this section, we specify the general setup for an Executor call into the
Runtime. In Section \ref{sect-runtime-entries} we specify the parameters and
the return values of each Runtime entry separately.

\subsubsection{Access to Runtime API}

When Polkadot RE calls a Runtime entry it should make sure Runtime has access
to the all Polkadot Runtime API functions described in Appendix
\ref{sect-runtime-entries}. This can be done for example by loading another
Wasm module alongside the runtime which imports these functions from Polkadot
RE as host functions.

\subsubsection{Sending Arguments to Runtime
}\label{sect-runtime-send-args-to-runtime-enteries}

In general, all data exchanged between Polkadot RE and the Runtime is encoded
using SCALE codec described in Section \ref{sect-scale-codec}. As a Wasm
function, all runtime entries have the following identical signatures:

\

\tmcodeinline[cpp]{\tmverbatim{}(func \$runtime\_entry (param \$data i32)
(param \$len i32) (result i64))}

\

In each invocation of a Runtime entry, the argument(s) which are supposed to
be sent to the entry, need to be encoded using SCALE codec into a byte array
$B$ using the procedure defined in Definition \ref{sect-scale-codec}.

The Executor then needs to retrieve the Wam memory buffer of the Runtime Wasm
module and extend it to fit the size of the byte array. Afterwards, it needs
to copy the byte array $B$ value in the correct offset of the extended buffer.
Finally, when the Wasm method \tmverbatim{runtime\_entry}, corresponding to
the entry is invoked, two UINT32 integers are sent to the method as arguments.
The first argument \tmverbatim{data} is set to the offset where the byte array
$B$ is stored in the Wasm the extended shared memory buffer. The second
argument \tmverbatim{len} sets the length of the data stored in $B$., and the
second one is the size of $B$.

\subsubsection{The Return Value from a Runtime
Entry}\label{sect-runtime-return-value}

The value which is returned from the invocation is an \tmverbatim{i64}
integer, representing two consecutive \tmverbatim{i32} integers in which the
least significant one indicates the pointer to the offset of the result
returned by the entry encoded in SCALE codec in the memory buffer. The most
significant one provides the size of the blob.

\section{Extrinsics}\label{sect-extrinsics}

The block body consists of an array of extrinsics. In a broad sense,
extrinsics are data from outside of the state which can trigger the state
transition. This section describes the specifications of the extrinsics and
their inclusion in the blocks.

\subsection{Preliminaries}

The extrinsics are divided in two main categories and defined as follows:

\begin{definition}
  {\tmstrong{Transaction extrinsics}} are extrinsics which are signed using
  either of the key types described in section \ref{sect-cryptographic-keys}
  and broadcasted between the nodes. {\tmstrong{Inherents extrinsics}} are
  unsigned extrinsics which are generated by Polkadot RE and only included in
  the blocks produced by the node itself. They are broadcasted as part of the
  produced blocks rather than being gossiped as individual extrinsics.
\end{definition}

Polkadot RE does not specify or limit the internals of each extrinsics and
those are dealt with by the Runtime. From Polkadot RE point of view, each
extrinsics is simply a SCALE-encoded blob (see Section
\ref{sect-scale-codec}).

\subsection{Transactions}

\subsubsection{Transaction Submission}

Transaction submission is made by sending a {\tmem{Transactions}} network
message. The structure of this message is specified in Section
\ref{sect-msg-transactions}. Upon receiving a Transactions message, Polkadot
RE decodes and decouples the transactions and calls
\tmverbatim{validate\_trasaction} Runtime entry, defined in Section
\ref{sect-rte-validate-transaction}, to check the validity of each received
transaction. If \tmverbatim{validate\_transaction} considers the submitted
transaction as a valid one, Polkadot RE makes the transaction available for
the consensus engine for inclusion in future blocks.

\subsection{Transaction Queue}

A Block producer node should listen to all transaction
messages{\tmem{{\index{Transaction Message}}}}. This is because the
transactions are submitted to the node through the {\tmem{transactions}}
network message specified in Section \ref{sect-msg-transactions}. Upon
receiving a transactions message, Polkadot RE separates the submitted
transactions in the transactions message into individual transactions and
passes them to the Runtime by executing Algorithm
\ref{algo-validate-transactions} to validate and store them for inclusion into
future blocks. To that aim, Polkodot RE should keep a {\tmem{transaction
pool{\index{transaction pool}}}} and a {\tmem{transaction
queue}}{\index{transaction queue}} defined as follows:

\begin{definition}
  \label{defn-transaction-queue}The {\tmstrong{Transaction Queue}} of a block
  producer node, formally referred to as $\tmop{TQ}$ is a data structure which
  stores the transactions ready to be included in a block sorted according to
  their priorities (Definition \ref{sect-msg-transactions}). The
  {\tmstrong{Transaction Pool}}, formally referred to as $\tmop{TP}$, is a
  hash table in which Polkadot RE keeps the list of all valid transactions not
  in the transaction queue.
\end{definition}

Algorithm \ref{algo-validate-transactions} updates the transaction pool and
the transaction queue according to the received message:

\custombinding{4}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{4}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-validate-transactions}{\tmname{Validate-Transactions-and-Store}}($M_T
      :$Transaction Message)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

In which
\begin{itemizeminus}
  \item {\tmname{Longest-Chain}} is defined in Definition
  \ref{defn-longest-chain}.
  
  \item \tmverbatim{TaggedTransactionQueue\_validate\_transaction} is a
  Runtime entry specified in Section \ref{sect-rte-validate-transaction} and
  Requires(R), Priority(R) and Propagate(R) refer to the corresponding fields
  in the tuple returned by the entry when it deems that $T$ is valid.
  
  \item {\tmname{Provided-Tags}}(T) is the list of tags that transaction $T$
  provides. Polkadot RE needs to keep track of tags that transaction $T$
  provides as well as requires after validating it.
  
  \item {\tmname{Insert-At(}}$\tmop{TQ}, T, \tmop{Requires} (R),
  \tmop{Priority} (R)$) places $T$ into $\tmop{TQ}$ approperietly such that
  the transactions providing the tags which $T$ requires or have higher
  priority than $T$ are ahead of $T$.
  
  \item {\tmname{Maintain-Transaction-Pool}} is described in Algorithm
  \ref{algo-maintain-transaction-pool}.
  
  \item {\tmname{Propagate(}}$T$) include $T$ in the next {\tmem{transactions
  message{\index{Transaction Message}}}} sent to all peers of Polkadot RE
  node.
\end{itemizeminus}
\custombinding{5}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{5}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-maintain-transaction-pool}{\tmname{Maintain-Transaction-Pool}}
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\subsubsection{Inherents}

Block inherent data represents the totality of inherent extrinsics included in
each block. This data is collected or generated by the Polkadot RE and handed
to the Runtime for inclusion in the block. It's the responsability of the RE
implementation to keep track of those values. Table \ref{tabl-inherent-data}
lists these inherent data, identifiers, and types. {\todo{define uncles}}

\begin{table}[h]
  \begin{tabular}{lll}
    \hline
    Identifier & Value type  & Description\\
    \hline
    timstap0 & u64 & Unix epoch time in number of milliseconds\\
    babeslot & u64 & Babe Slot Number\tmrsup{\ref{defn-epoch-slot}} of the
    current building block\\
    finalnum & compact integer$^{\ref{defn-sc-len-encoding}}$ & Header
    number$^{\ref{defn-block-header}}$ of the last finalized block\\
    uncles00 & array of block headers$^{}$ & Provides a list of potential
    uncle block headers$^{\ref{defn-block-header}}$ for a given block\\
    \hline
  \end{tabular}
  \caption{\label{tabl-inherent-data}List of inherent data}
\end{table}

\begin{definition}
  \label{defn-inherent-data}{\tmname{Inherent-Data }}is a hashtable
  (Definition \ref{defn-scale-list}) representing the totality of inherent
  extrinsics included in each block. The entries of this hash table which are
  listed in Table \ref{tabl-inherent-data} are collected or generated by the
  Polkadot RE and then handed to the Runtime for inclusion as dercribed in
  Algorithm \ref{algo-build-block}. The identifiers are 8-byte values.
\end{definition}

\section{State Replication}\label{sect-state-replication}

Polkadot nodes replicate each other's state by syncing the history of the
extrinsics. This, however, is only practical if a large set of transactions
are batched and synced at the time. The structure in which the transactions
are journaled and propagated is known as a block (of extrinsics) which is
specified in Section \ref{sect-block-format}. Like any other replicated state
machines, state inconsistency happens across Polkadot replicas. Section
\ref{sect-managing-multiple-states} is giving an overview of how a Polkadot RE
node manages multiple variants of the state.

\subsection{Block Format}\label{sect-block-format}

In Polkadot RE, a block is made of two main parts, namely the \tmtextit{block
header} and the \tmtextit{list of extrinsics}. {\tmem{The Extrinsics}}
represent the generalization of the concept of {\tmem{transaction}},
containing any set of data that is external to the system, and which the
underlying chain wishes to validate and keep track of.

\subsubsection{Block Header}\label{block}

The block header is designed to be minimalistic in order to boost the
efficiency of the light clients. It is defined formally as follows:

\begin{definition}
  \label{defn-block-header}The {\tmstrong{header of block B}},
  {\tmstrong{$\tmop{Head} (B)$}} is a 5-tuple containing the following
  elements:
  \begin{itemize}
    \item \tmtextbf{{\tmsamp{parent\_hash:}}} is the 32-byte Blake2b hash (see
    Section \ref{sect-blake2}) of the header of the parent of the block
    indicated henceforth by \tmtextbf{$H_p$}.
    
    \item {\tmstrong{{\tmsamp{number:}}}} formally indicated as
    {\tmstrong{$H_i$}} is an integer, which represents the index of the
    current block in the chain. It is equal to the number of the ancestor
    blocks. The genesis state has number 0.
    
    \item {\tmstrong{{\tmsamp{state\_root:}}}} formally indicated as
    {\tmstrong{$H_r$}} is the root of the Merkle trie, whose leaves implement
    the storage for the system.
    
    \item {\tmstrong{{\tmsamp{extrinsics\_root:}}}} is the field which is
    reserved for the Runtime to validate the integrity of the extrinsics
    composing the block body. For example, it can hold the root hash of the
    Merkle trie which stores an ordered list of the extrinsics being validated
    in this block. The {\tmsamp{extrinsics\_root}} is set by the runtime and
    its value is opaque to Polkadot RE. This element is formally referred to
    as {\tmstrong{$H_e$}}.
    
    \item {\tmstrong{{\tmsamp{digest:}}}} this field is used to store any
    chain-specific auxiliary data, which could help the light clients interact
    with the block without the need of accessing the full storage as well as
    consensus-related data including the block signature. This field is
    indicated as {\tmstrong{$H_d$}} and its detailed format is defined in
    Definition \ref{defn-digest}
  \end{itemize}
\end{definition}

\begin{definition}
  \label{defn-digest}The header {\tmstrong{digest}} of block $B$ formally
  referred to by {\tmstrong{$H_d (B)$}} is an array of {\tmstrong{digest
  items}} $H^i_d$'s , known as digest items of varying data type (see
  Definition \ref{defn-varrying-data-type}) such that
  \[ H_d (B) : = H^1_d, \ldots, H^n_d \]
  where each digest item can hold one of the type described in Table
  \ref{tabl-digest-items}:
  
  \begin{center}
    \tmfloat{h}{small}{table}{
    {\center{\begin{tabular}{|r|l|l|}
      \hline
      Type Id & Type name & sub-components \\
      \hline
      $2$ & Changes trie root & $\mathbb{B}_{32}$\\
      6 & Pre-Runtime & $E_{\tmop{id}}, \mathbb{B}$\\
      4 & Consensus Message & $E_{\tmop{id}}, \mathbb{B}$\\
      5 & Seal  & $E_{\tmop{id}}, \mathbb{B}$\\
      \hline
    \end{tabular}}}
    }{\label{tabl-digest-items}The detail of the varying type that a digest
    item can hold.}
  \end{center}
  
  \
  
  Where $E_{\tmop{id}}$ is the unique consensus engine identifier defined in
  Section \ref{sect-msg-consensus}. and
  \begin{itemizedot}
    \item [FUTURE-RESERVED, currently not used] {\tmstrong{Changes trie root}}
    contains the root of changes trie at block $B$ as defined in Definition
    \ref{defn-changes-trie}.
    
    \item {\tmstrong{Pre-runtime}} digest item represents messages produced by
    a consensus engine to the Runtime.
    
    \item {\tmstrong{Consensus}} \tmtextbf{Message} digest item represents a
    message from the Runtime to the consensus engine (see Section
    \ref{sect-consensus-message-digest}).
    
    \item {\tmstrong{Seal}} is the data produced by the consensus engine and
    proving the authorship of the block producer. In particular, the Seal
    digest item must be the last item in the digest array and must be stripped
    off before the block is submitted to the Runtime for validation and be
    added back to the digest afterward. The detail of the Seal digest item is
    laid out in Definition \ref{defn-babe-seal}.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-block-header-hash}The {\tmstrong{Block Header Hash of Block
  $B$}}, {\tmstrong{$H_h (B)$}}, is the hash of the header of block $B$
  encoded by simple codec:''
  \[ H_h (B) \assign \tmop{Blake} 2 b (\tmop{Enc}_{\tmop{SC}} (\tmop{Head}
     (B))) \]
\end{definition}

\subsubsection{Justified Block Header}\label{sect-justified-block-header}

The Justified Block Header is provided by the consensus engine and presented
to the Polkadot RE, for the block to be appended to the blockchain. It
contains the following parts:
\begin{itemize}
  \item {\tmstrong{{\tmsamp{{\tmstrong{block\_header}}}}}} the complete block
  header as defined in Section \ref{block} and denoted by $\tmop{Head} (B)$.
  
  \item {\tmstrong{{\tmsamp{justification}}}}: as defined by the consensus
  specification indicated by $\tmop{Just} (B)$ {\todo{link this to its
  definition from consensus}}.
  
  \item {\tmstrong{{\tmsamp{authority Ids}}}}: This is the list of the Ids of
  authorities, which have voted for the block to be stored and\tmverbatim{} is
  formally referred to as $A (B)$. An authority Id is 32bit.
\end{itemize}
\subsubsection{Block Body}\label{sect-block-body}

The Block Body consists of array extrinsics each encoded as a byte array. The
internal of extrinsics is completely opaque to Polkadot RE. As such, it forms
the point of Polkadot RE, and is simply a SCALE encoded array of byte arrays.
Formally:

\begin{definition}
  \label{defn-block-body}The {\tmstrong{body of Block}} $B$ represented as
  {\tmstrong{$\tmop{Body} (B)$}} is defined to be
  \[ \tmop{Body} (B) \assign \tmop{Enc}_{\tmop{SC}} (E_1, \ldots, E_n) \]
  Where each $E_i \in \mathbb{B}$ is a SCALE encoded extrinsic.
\end{definition}

\subsection{Block Submission}\label{sect-block-submission}

Block validation is the process by which the client asserts that a block is
fit to be added to the blockchain. This means that the block is consistent
with the world state and transitions from the state of the system to a new
valid state.

Blocks can be handed to the Polkadot RE both from the network stack for
example by means of Block response network message (see Section
\ref{sect-msg-block-response} ) and from the consensus engine.

\subsection{Block Validation}\label{sect-block-validation}

Both the Runtime and the Polkadot RE need to work together to assure block
validity. A block is deemed valid if the block author had the authorship right
for the slot during which the slot was built as well as if the transactions in
the block constitute a valid transition of states. The former criterion is
validated by Polkadot RE according to the block production consensus protocol.
The latter can be verified by Polkadot RE invoking \tmverbatim{execute\_block}
entry into the Runtime as a part of the validation process.

Polkadot RE implements the following procedure to assure the validity of the
block:

\custombinding{6}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{6}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-import-and-validate-block}{\tmname{Import-and-Validate-Block($B,
      \tmop{Just} (B)$)}}
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

For the definition of the finality and the finalized block see Section
\ref{sect-finality}. $\tmop{PBT}$ is the pruned block tree defined in
Definition \ref{defn-block-tree}. {\tmname{Verify-Authorship-Right}} is part
of the block production consensus protocol and is described in Algorithm
\ref{algo-verify-authorship-right}.

\subsection{Managaing Multiple Variants of
State}\label{sect-managing-multiple-states}

Unless a node is committed to only update its state according to the finalized
block (See Definition \ref{defn-finalized-block}), it is inevitable for the
node to store multiple variants of the state (one for each block). This is,
for example, necessary for nodes participating in the block production and
finalization.

While the state trie structure described in Section
\ref{sect-state-storage-trie-structure} facilitates and optimizes storing and
switching between multiple variants of the state storage, Polkadot RE does not
specify how a node is required to accomplish this task. Instead, Polkadot RE
is required to implement {\tmname{Set-State-At}} operation which behaves as
defined in Definition \ref{defn-set-state-at}:

\begin{definition}
  \label{defn-set-state-at}The function
  \[ \text{{\tmname{{\tmstrong{Set-State-At($\tmmathbf{B}$)}}}}} \]
  in which $B$ is a block in the block tree (See Definition
  \ref{defn-block-tree}), sets the content of state storage equal to the
  resulting state of executing all extrinsics contained in the branch of the
  block tree from genesis till block B including those recorded in Block B.
\end{definition}

For the definition of the state storage see Section
\ref{sect-state-storage}.\chapter{Network
Protocol\label{sect-network-interactions}}\label{network-protocol}

\begin{warning}
  Polkadot network protocol is work-in-progress. The API specification and
  usage may change in future.
\end{warning}

This chapter offers a high-level description of the network protocol based on
{\cite{parity_technologies_substrate_2019}}. Polkadot network protocol relies
on {\tmem{libp2p}}. Specifically, the following libp2p modules are being used
in the Polkadot Networking protocol:
\begin{itemize}
  \item {\tmsamp{mplex.}}
  
  \item {\tmsamp{yamux}}
  
  \item {\tmsamp{secio}}
  
  \item {\tmsamp{noise}}
  
  \item {\tmsamp{kad}} (kademlia)
  
  \item {\tmsamp{identity}}
  
  \item {\tmsamp{ping}}
\end{itemize}
For more detailed specification of these modules and the Peer-to-Peer layer
see libp2p specification document {\cite{protocol_labs_libp2p_2019}}.

\section{Node Identities and Addresses}

Similar to other decentralized networks, each Polkadot RE node possesses a
network private key and a network public key representing an ED25519 key pair
{\cite{liusvaara_edwards-curve_2017}}.

{\todo{SPEC: local node's keypair must be passed as part of the network
configuration.}}

\begin{definition}
  {\tmstrong{Peer Identity}}, formally noted by $P_{\tmop{id}}$ is derived
  from the node's public key as follows:
  
  {\todo{SPEC: How to derive $P_{\tmop{id}}$}} \ and uniquely identifies a
  node on the network.
\end{definition}

Because the $P_{\tmop{id}}$ is derived from the node's public key, running two
or more instances of Polkadot network using the same network key is contrary
to the Polkadot protocol.

All network communications between nodes on the network use encryption derived
from both sides' keys.

{\todo{SPEC: p2p key derivation}}

\section{Discovery Mechanisms}

In order for a Polkadot node to join a peer-to-peer network, it has to know a
list of Polkadot nodes that already take part in the network. This process of
building such a list is referred to as {\tmem{Discovery}}. Each element of
this list is a pair consisting of the peer's node identities and their
addresses.

{\todo{SPEC: Node address}}

Polkadot discovery is done through the following mechanisms:
\begin{itemize}
  \item {\tmem{Bootstrap nodes}}: These are hard-coded node identities and
  addresses passed alongside with the network configuration.
  
  \item {\tmem{mDNS}}, performing a UDP broadcast on the local network. Nodes
  that listen may respond with their identity as described in the mDNS section
  of {\cite{protocol_labs_libp2p_2019}}. (Note: mDNS can be disabled in the
  network configuration.)
  
  \item {\tmem{Kademlia random walk}}. Once connected to a peer node, a
  Polkadot node can perform a random Kademlia `FIND\_NODE` requests for the
  nodes {\todo{which nodes?}} to respond by propagating their view of the
  network.
\end{itemize}
\section{Transport Protocol}\label{sect_transport_protocol}

A Polkadot node can establish a connection with nodes in its peer list. All
the connections must always use encryption and multiplexing. While some nodes'
addresses (eg. addresses using `/quic`) already imply the encryption and/or
multiplexing to use, for others the ``multistream-select'' protocol is used in
order to negotiate an encryption layer and/or a multiplexing layer.

The following transport protocol is supported by a Polkadot node:
\begin{itemize}
  \item {\tmem{TCP/IP}} for addresses of the form `/ip4/1.2.3.4/tcp/5`. Once
  the TCP connection is open, an encryption and a multiplexing layers are
  negotiated on top.
  
  \item {\tmem{WebSockets}} for addresses of the form `/ip4/1.2.3.4/tcp/5/ws`.
  A TC/IP connection is open and the WebSockets protocol is negotiated on top.
  Communications then happen inside WebSockets data frames. Encryption and
  multiplexing are additionally negotiated again inside this channel.
  
  \item DNS for addresses of the form `/dns4/example.com/tcp/5` or
  `/dns4/example.com/tcp/5/ws`. A node's address can contain a domain name.
\end{itemize}

\subsection{Encryption}

The following encryption protocols from libp2p are supported by Polkadot
protocol:

\item {\tmstrong{Secio}}: A TLS-1.2-like protocol but without certificates
{\cite{protocol_labs_libp2p_2019}}. Support for secio will likely to be
deprecated in the future.

\item {\tmstrong{Noise}}: Noise is a framework for crypto protocols based on
the Diffie-Hellman key agreement {\cite{perrin_noise_2018}}. Support for noise
is experimental and details may change in the future.

\subsection{Multiplexing}

The following multiplexing protocols are supported:
\begin{itemize}
  \item {\tmstrong{Mplex}}: Support for mplex will be deprecated in the
  future.
  
  \item {\tmstrong{Yamux}}.
\end{itemize}

\section{Substreams}

Once a connection has been established between two nodes and is able to use
multiplexing, substreams can be opened. When a substream is open, the
{\tmem{multistream-select}} protocol is used to negotiate which protocol to
use on that given substream.

\subsection{Periodic Ephemeral Substreams}

A Polkadot RE node should open several substreams. In particular, it should
periodically open ephemeral substreams in order to:
\begin{itemize}
  \item ping the remote peer and check whether the connection is still alive.
  Failure for the remote peer to reply leads to a disconnection. This uses the
  libp2p {\tmem{ping}} protocol specified in
  {\cite{protocol_labs_libp2p_2019}}.
  
  \item ask information from the remote. This is the {\tmem{identity}}
  protocol specified in {\cite{protocol_labs_libp2p_2019}}.
  
  \item send Kademlia random walk queries. Each Kademlia query is done in a
  new separate substreams. This uses the libp2p {\tmem{Kademlia}} protocol
  specified in {\cite{protocol_labs_libp2p_2019}}.
\end{itemize}
\subsection{Polkadot Communication
Substream}\label{sect_polkadot_communication_substream}

For the purposes of communicating Polkadot messages, the dailer of the
connection opens a unique substream. Optionally, the node can keep a unique
substream alive for this purpose. The name of the protocol negotiated is based
on the {\tmem{protocol ID}} passed as part of the network configuration. This
protocol ID should be unique for each chain and prevents nodes from different
chains to connect to each other.

The structure of SCALE encoded messages sent over the unique Polkadot
communication substream is described in Appendix \ref{sect-network-messages}.

Once the substream is open, the first step is an exchange of a {\tmem{status}}
message from both sides described in Section \ref{sect-msg-status}.

Communications within this substream include:
\begin{itemize}
  \item Syncing. Blocks are announced and requested from other nodes.
  
  \item Gossiping. Used by various subprotocols such as GRANDPA.
  
  \item Polkadot Network Specialization: {\todo{spec this protocol for
  polkadot}}.
\end{itemize}
\chapter{Consensus}\label{chap-consensu}

Consensus in Polkadot RE is achieved during the execution of two different
procedures. The first procedure is block production and the second is
finality. Polkadot RE must run these procedures, if and only if it is running
on a validator node.

\section{Common Consensus Structures}

\subsection{Consensus Authority Set}\label{sect-authority-set}

Because Polkadot is a proof-of-stake protocol, each of its consensus engine
has its own set of nodes, represented by known public keys which have the
authority to influence the protocol in pre-defined ways explained in this
section. In order to verifiy the validity of each block, Polkadot node must
track the current list of authorities for that block as formalised in
Definition \ref{defn-authority-list}

\begin{definition}
  \label{defn-authority-list}The {\tmstrong{authority list}} of block $B$ for
  consensus engine $C$ noted as {\tmstrong{$\tmop{Auth}_C (B)$}} \ is an array
  of pairs of type:
  \[ (\tmop{Pk}_A, W_A) \]
  $P_A$ is the session public key of authority A as defined in Definition
  \ref{defn-session-key}. And $W_A$ is a \tmverbatim{u64} value, indicating
  the authority weight which is set to equal to 1. The value of $\tmop{Auth}_C
  (B)$ is part of the Polkadot state. The value for $\tmop{Auth}_C (B_0)$ is
  set in the genesis state (see Section \ref{sect-genesis-block}) and can be
  retrieved using a runtime entery corresponding to consensus engine $C$.
\end{definition}

Note that in Polkadot, all authorities have the weight equal to 1. The weight
$W_A$ in Definition \ref{defn-authority-list} exists for potential
improvements in the protocol and could have a use-case in the future.

\subsection{Runtime-to-Consensus Engine
Message}\label{sect-consensus-message-digest}

The authority lists (see Definition \ref{defn-authority-list}) is part of
Polkadot state and the Runtime has the authority of updating the lists in the
course of state transitions. The runtime inform the corresponding consensus
engine about the changes in the authority set by means of setting a consensus
message digest item as defined in Definition
\ref{defn-consensus-message-digest}, in the block header of block $B$ during
which course of exectution the transition in the authority set has occured.

\begin{definition}
  \label{defn-consensus-message-digest} Consensus Message is digest item of
  type 4 as defined in Definition \ref{defn-digest} and consists of the pair:
  \[ (E_{\tmop{id}}, \tmop{CM}) \]
  Where $E_{\tmop{id}} \in \mathbb{B}_4$ is the consensus engine unique
  identifier which can hold the following possible values
  
  
  \[ E_{\tmop{id}} \assign \left\{ \begin{array}{ccc}
       '' \tmop{BABE}'' &  & \tmop{For} \tmop{messages} \tmop{related}
       \tmop{to} \tmop{BABE} \tmop{protocol} \tmop{refered} \tmop{to}
       \tmop{as} E_{\tmop{id}} (\tmop{BABE})\\
       '' \tmop{FRNK}'' &  & \tmop{For} \tmop{messages} \tmop{related}
       \tmop{to} \tmop{GRANDPA} \tmop{protocol} \tmop{referred} \tmop{to}
       \tmop{as} E_{\tmop{id}} (\tmop{FRNK})
     \end{array} \right. \]
  and CM is of varying data type which can hold one of the type described in
  Table \ref{tabl-consensus-messages}:
  {\center{\tmfloat{h}{small}{table}{\begin{tabular}{l|l|l}
    {\tmstrong{Type Id}} & {\tmstrong{Type}} & {\tmstrong{Sub-components}}\\
    \hline
    1 & Scheduled Change & $(\tmop{Auth}_C, N_{\tmop{delay}})$\\
    2 & ForcedChange & $(\tmop{Auth}_C, N_{\tmop{delay}})$\\
    3 & On Disabled & $\tmop{Auth}_{\tmop{ID}}$\\
    4 & Pause & $N_{\tmop{delay}}$\\
    5 & Resume & N$_{\tmop{delay}}$
  \end{tabular}}{\label{tabl-consensus-messages}The consensus digest item for
  GRANDPA authorities}}}
  Where:
  \begin{itemizeminus}
    \item Auth$_C$ is the authority list defined in Definition
    \ref{defn-authority-list}.
    
    \item $N_{\tmop{delay}} \assign | \nobracket${\tmname{SubChain}}$(B, B') |
    \nobracket$ is an unsigned 32 bit integer indicating the length of the
    subchain starting at $B$, the block containing the consensus message in
    its header digest and ending when it reaches $N_{\tmop{delay}}$ length as
    a path graph. The last block in that subchain, $B'$, depending on the
    message type, is either finalized or imported (and therefore validated by
    the block production consensus engine according to Algorithm
    \ref{algo-import-and-validate-block}. see below for details).
    
    \item $\tmop{Auth}_{\tmop{ID}}$ is an unsigned 64 bit integer pointing to
    an individual authority in the current authority list.
  \end{itemizeminus}
\end{definition}

Polkadot RE should inspect the digest header of each block and delegates
consesus messages to their consensus engines. Consensus engine should react
based on the type of consensus messages they receives as follows:
\begin{itemizeminus}
  \item {\tmstrong{Scheduled Change}}: Schedule an authority set change after
  the given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is a block {\tmem{finalized}} by the
  finality consensus engine. The earliest digest of this type in a single
  block will be respected. No change should be scheduled if one is already and
  the delay has not passed completely. If such an inconsitency occures, the
  scheduled change should be ignored.
  
  \item {\tmstrong{Forced Change}}: Force an authority set change after the
  given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is an {\tmem{imported}} block which has
  been validated by the block production conensus engine. Hence, the authority
  change set is valid for every subchain which contains {\tmem{B}} and where
  the delay has been exceeded. If one or more blocks gets finalized before the
  change takes effect, the authority set change should be disregarded. The
  earliest digest of this type in a single block will be respected. No change
  should be scheduled if one is already and the delay has not passed
  completely. If such an inconsitency occures, the scheduled change should be
  ignored.
  
  \item {\tmstrong{On Disabled}}: An index to the individual authority in the
  current authority list that should be immediately disabled until the next
  authority set change. When an authority gets disabled, the node should stop
  performing any authority functionality from that authority, including
  authoring blocks and casting GRANDPA votes for finalization. Similarly,
  other nodes should ignore all messages from the indicated authority which
  pretain to their authority role.
  
  \item {\tmstrong{Pause}}: A signal to pause the current authority set after
  the given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is a block {\tmem{finalized}} by the
  finality consensus engine. After finalizing block $B'$, the authorities
  should stop voting.
  
  \item {\tmstrong{Resume}}: A signal to resume the current authority set
  after the given delay of $N_{\tmop{delay}} \assign |
  \nobracket${\tmname{SubChain}}$(B, B') | \nobracket$ where $B'$ in the
  definition of $N_{\tmop{delay}}$, is an {\tmem{imported}} block and
  validated by the block production consensus engine. After authoring the
  block $B'$, the authorities should resume voting.
\end{itemizeminus}
The active GRANDPA authorities can only vote for blocks that occured after the
finalized block in which they were selected. Any votes for blocks before the
\tmverbatim{Scheduled Change} came into effect get rejected.

\section{Block Production}\label{sect-babe}\label{sect-block-production}

Polkadot RE uses BABE protocol {\cite{w3f_research_group_blind_2019}} for
block production. It is designed based on Ouroboros praos
{\cite{david_ouroboros_2018}}. BABE execution happens in sequential
non-overlapping phases known as an {\tmstrong{{\tmem{epoch}}}}. Each epoch on
its turn is divided into a predefined number of slots. All slots in each epoch
are sequentially indexed starting from 0. At the beginning of each epoch, the
BABE node needs to run Algorithm \ref{algo-block-production-lottery} to find
out in which slots it should produce a block and gossip to the other block
producers. In turn, the block producer node should keep a copy of the block
tree and grow it as it receives valid blocks from other block producers. A
block producer prunes the tree in parallel by eliminating branches which do
not include the most recent finalized blocks according to Definition
\ref{defn-pruned-tree}.

\subsection{Preliminaries}

\begin{definition}
  A {\tmstrong{block producer}}, noted by $\mathcal{P}_j$, is a node running
  Polkadot RE which is authorized to keep a transaction queue and which gets a
  turn in producing blocks.
\end{definition}

\begin{definition}
  {\tmstrong{Block authoring session key pair $(\tmop{sk}^s_j,
  \tmop{pk}^s_j)$}} is an SR25519 key pair which the block producer
  $\mathcal{P}_j$ signs by their account key (see Definition
  \ref{defn-account-key}) and is used to sign the produced block as well as to
  compute its lottery values in Algorithm \ref{algo-block-production-lottery}.
  
\end{definition}

\begin{definition}
  \label{defn-epoch-slot}A block production {\tmstrong{epoch}}, formally
  referred to as $\mathcal{E}$, is a period with pre-known starting time and
  fixed length during which the set of block producers stays constant. Epochs
  are indexed sequentially, and we refer to the $n^{\tmop{th}}$ epoch since
  genesis by $\mathcal{E}_n$. Each epoch is divided into equal length periods
  known as block production {\tmstrong{slots}}, sequentially indexed in each
  epoch. The index of each slot is called {\tmstrong{slot number}}. The equal
  length duration of each slot is called the {\tmstrong{slot duration}} and
  indicated by $\mathcal{T}$. Each slot is awarded to a subset of block
  producers during which they are allowed to generate a block.
\end{definition}

\begin{notation}
  \label{note-slot}We refer to the number of slots in epoch $\mathcal{E}_n$ by
  $\tmop{sc}_n$. $\tmop{sc}_n$ is set to the \tmverbatim{duration} field in
  the returned data from the call of the Runtime entry
  \tmverbatim{BabeApi\_configuration} (see \ref{sect-rte-babeapi-epoch}) at
  the beginning of each epoch. For a given block $B$, we use the notation
  {\tmstrong{$s_B$}} to refer to the slot during which $B$ has been produced.
  Conversely, for slot $s$, $\mathcal{B}_s$ is the set of Blocks generated at
  slot $s$.
\end{notation}

Definition \ref{defn-epoch-subchain} provides an iterator over the blocks
produced during an specific epoch.

\begin{definition}
  \label{defn-epoch-subchain} By {\tmname{SubChain($\mathcal{E}_n$)}} for
  epoch $\mathcal{E}_n$, we refer to the path graph of $\tmop{BT}$ which
  contains all the blocks generated during the slots of epoch $\mathcal{E}_n$.
  When there is more than one block generated at a slot, we choose the one
  which is also on {\tmname{Longest-Chain($\tmop{BT}$)}}.
\end{definition}

\subsection{Block Production Lottery}

\begin{definition}
  \label{defn-winning-threshold}{\tmstrong{Winning threshold}} denoted by
  {\tmstrong{$\tau_{\varepsilon_n}$}} is the threshold which is used alongside
  with the result of Algorirthm \ref{algo-block-production-lottery} to decide
  if a block producer is the winner of a specific slot. $\tau_{\varepsilon_n}$
  is calculated \ as follows:
  \[ \tau_{\varepsilon_n} \assign 1 - (1 - c)^{\frac{1}{|
     \tmop{AuthorityDirectory}^{\mathcal{E}_n} |}} \]
  where $\tmop{AuthorityDirectory}^{\mathcal{E}_n}$ is the set of BABE
  authorities for epoch $\varepsilon_n$ and $c =
  \frac{c_{\tmop{nominator}}}{c_{\tmop{denominator}}}$. The pair
  $(c_{\tmop{nominator}}, c_{\tmop{denominator}})$ can be retrieve part of the
  data returned by a call into runtime entry
  \tmverbatim{BabeApi\_configuration}.
\end{definition}

A block producer aiming to produce a block during $\mathcal{E}_n$ should run
Algorithm \ref{algo-block-production-lottery} to identify the slots it is
awarded. These are the slots during which the block producer is allowed to
build a block. The $\tmop{sk}$ is the block producer lottery secret key and
$n$ is the index of epoch for whose slots the block producer is running the
lottery.

\custombinding{7}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{7}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-block-production-lottery}{\tmname{Block-production-lottery}}($\tmop{sk}
      :$session secret key of the producer,
      
      $n :$epoch index)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

For any slot $i$ in epoch $n$ where $d < \tau$, the block producer is required
to produce a block. For the definitions of {\tmname{Epoch-Randomness}} and
{\tmem{{\tmname{VRF}}}} functions, see Algorithm \ref{algo-epoch-randomness}
and Section \ref{sect-vrf} respectively.

\subsection{Slot Number Calculation}

It is essential for a block producer to calculate and validate the slot number
at a certain point in time. Slots are dividing the time continuum in an
overlapping interval. At a given time, the block producer should be able to
determine the set of slots which can be associated to a valid block generated
at that time. We formalize the notion of validity in the following
definitions:

\begin{definition}
  \label{slot-time-cal-tail}The {\tmstrong{slot tail}}, formally referred to
  by $\tmop{SlTl}$ represents the number of on-chain blocks that are used to
  estimate the slot time of a given slot. This number is set to be 1200.
\end{definition}

Algorithm \ref{algo-slot-time} determines the slot time for a future slot
based on the {\tmem{block arrival time}} associated with blocks in the slot
tail defined in Definition \ref{defn-block-time}.

\begin{definition}
  \label{defn-block-time}The {\tmstrong{block arrival time}} of block $B$ for
  node $j$ formally represented by {\tmstrong{$T^j_B$}} is the local time
  of\tmverbatim{} node $j$ when node $j$ has received the block $B$ for the
  first time. If the node $j$ itself is the producer of $B$, $T_B^j$ is set
  equal to the time that the block is produced. The index $j$ in $T^j_B$
  notation may be dropped and B's arrival time is referred to by $T_B$ when
  there is no ambiguity about the underlying node.
\end{definition}

In addition to the arrival time of block $B$, the block producer also needs to
know how many slots have passed since the arrival of $B$. This value is
formalized in Definition \ref{defn-slot-offset}.

\begin{definition}
  \label{defn-slot-offset}Let $s_i$ and $s_j$ be two slots belonging to epochs
  $\mathcal{E}_k$ and $\mathcal{E}_l$. By {\tmname{Slot-Offset}}$(s_i, s_j)$
  we refer to the function whose value is equal to the number of slots between
  $s_i$ and $s_j$ (counting $s_j$) on time continuum. As such, we have
  {\tmname{Slot-Offset}}$(s_i, s_i) = 0$.
\end{definition}

\custombinding{8}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{8}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-slot-time}{\tmname{Slot-Time}}($s$: the slot number of the
      slot whose time needs to be determined)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

$\mathcal{T}$ is the slot duration defined in Definition
\ref{defn-epoch-slot}.

\subsection{Block Production}

At each epoch, each block producer should run Algorithm
\ref{algo-block-production} to produce blocks during the slots it has been
awarded during that epoch. The produced block needs to carry {\tmem{BABE
header}} as well as the {\tmem{block signature}} \ as Pre-Runtime and Seal
digest items defined in Definition \ref{defn-babe-header} and
\ref{defn-block-signature} respectively.

\begin{definition}
  The \label{defn-babe-header}{\tmstrong{BABE Header}} of block B, referred to
  formally by {\tmstrong{$H_{\tmop{BABE}} (B)$}} is a tuple that consists of
  the following components:
  \[ (d, \pi, j, s) \]
  in which:
  
  \begin{center}
    \begin{tabular}{rl}
      $\pi, d$: & are the results of the block lottery for slot s. \\
      $j$: & is index of the block producer producing block in the current
      authority directory of current epoch. \\
      s: & is the slot at which the block is produced.
    \end{tabular}
    
    \ 
  \end{center}
  
  \
  
  $H_{\tmop{BABE}} (B)$ must be included as a diegst item of Pre-Runtime type
  in the header digest $H_d (B)$ as defined in Definition \ref{defn-digest}. 
\end{definition}

\begin{definition}
  \label{defn-block-signature}\label{defn-babe-seal}The {\tmstrong{Block
  Signature}} noted by $S_B$ is computed as
  \[ \tmop{Sig}_{\tmop{SR} 25519, \tmop{sk}^s_j} (H_h (B)) \]
  $S_B$ should be included in $H_d (B)$ as the Seal digest item according to
  Definition \ref{defn-digest} of value:
  \[ (E_{\tmop{id}} (\tmop{BABE}), S_B) \]
  in which, $E_{\tmop{id}} (\tmop{BABE})$ is the BABE consensus engine unique
  identifier defined in Section \ref{sect-msg-consensus}. The Seal digest item
  is referred to as {\tmstrong{BABE Seal}}.
  
  \ 
\end{definition}

\custombinding{9}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{9}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-block-production}\tmverbatim{}{\tmname{Invoke-Block-Authoring}}($\tmop{sk}$,
      pk, $n$, $\tmop{BT} : \tmop{Current} \tmop{Block} \tmop{Tree}$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

{\tmname{Add-Digest-Item}} appends a digest item to the end of the header
digest $H_d (B)$ according to Definition \ref{defn-digest}.

\subsection{Epoch Randomness}\label{sect-epoch-randomness}

At the end of epoch $\mathcal{E}_n$, each block producer is able to compute
the randomness seed it needs in order to participate in the block production
lottery in epoch $\mathcal{E}_{n + 2}$. For epoch 0 and 1, the randomness seed
is provided in the genesis state. The computation of the seed is described in
Algorithm \ref{algo-epoch-randomness} which uses the concept of epoch subchain
described in Definition \ref{defn-epoch-subchain}.

\custombinding{10}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{10}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-epoch-randomness}{\tmname{Epoch-Randomness}}($n > 2 :$epoch
      index)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

In which value $d_B$ is the VRF output computed for slot $s_B$ by running
Algorithm \ref{algo-block-production-lottery}.

\

\subsection{Verifying Authorship Right}\label{sect-verifying-authorship}

When a Polkadot node receives a produced block, it needs to verify if the
block producer was entitled to produce the block in the given slot by running
Algorithm \ref{algo-verify-authorship-right} where:
\begin{itemizeminus}
  \item T$_B$ is $B$'s arrival time defined in Definition
  \ref{defn-block-time}.
  
  \item $H_d (B)$ is the digest sub-component of $\tmop{Head} (B)$ defined in
  Definitions \ref{defn-block-header} and \ref{defn-digest}.
  
  \item The Seal $D_s$ is the last element in the digest array $H_d (B)$ as
  defined in Definition \ref{defn-digest}.
  
  \item {\tmname{Seal-Id}} is the type index showing that a digest item of
  variable type is of {\tmem{Seal}} type (See Definitions
  \ref{defn-scale-variable-type} and \ref{defn-digest})
  
  \item $\tmop{AuthorityDirectory}^{\mathcal{E}_c}$ is the set of Authority ID
  for block producers of epoch $\mathcal{E}_c$.
  
  \item {\tmname{verify-Slot-Winner}} is defined in Algorithm
  \ref{algo-verify-slot-winner}.
\end{itemizeminus}
\custombinding{11}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{11}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-verify-authorship-right}{\tmname{Verify-Authorship-Right}}($\tmop{Head}_s
      (B)$: The header of the block being verified) 
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

Algorithm \ref{algo-verify-slot-winner} is run as a part of the verification
process, when a node is importing a block, in which:
\begin{itemizeminus}
  \item {\tmname{Epoch-Randomness}} is defined in Algorithm
  \ref{algo-epoch-randomness}.
  
  \item $H_{\tmop{BABE}} (B)$ is the BABE header defined in Definition
  \ref{defn-babe-header}.
  
  \item {\tmname{Verify-VRF}} is described in Section \ref{sect-vrf}.
  
  \item $\tau$ is the winning threshold defined in
  \ref{defn-winning-threshold}.
\end{itemizeminus}
\custombinding{12}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{12}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-verify-slot-winner}{\tmname{Verify-Slot-Winner}}($B$: the
      block whose winning status to be verified)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

$(d_B, \pi_B)$: Block Lottery Result for Block $B$,

$s_n$: the slot number,

$n$: Epoch index

AuthorID: The public session key of the block producer

\subsection{Block Building Process}\label{sect-block-building}

The blocks building process is triggered by Algorithm
\ref{algo-block-production} of the consensus engine which runs Alogrithm
\ref{algo-build-block}.

\custombinding{13}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{13}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-build-block}{\tmname{Build-Block}}($C_{\tmop{Best}}$: The
      chain where at its head, the block to be constructed,
      
      s: Slot number)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}
\begin{itemizeminus}
  \item $\tmop{Head} (B)$ is defined in Definition \ref{defn-block-header}.
  
  \item {\tmname{Call-Runtime-Entry}} is defined in Notation
  \ref{nota-call-into-runtime}.
  
  \item {\tmname{Inherent-Data}} is defined in Definition
  \ref{defn-inherent-data}.
  
  \item {\tmname{Transaction-Queue}} is defined in Definition
  \ref{defn-transaction-queue}.
  
  \item {\tmname{Block-Is-Full}} indicates that the maximum block size as been
  used.
  
  \item {\tmname{End-Of-Slot}} indicates the end of the BABE slot as defined
  in Algorithm \ref{algo-slot-time} respectively Definition
  \ref{defn-epoch-slot}.
  
  \item {\tmname{Ok-Result}} indicates whether the result of
  \tmverbatim{BlockBuilder\_apply\_extrinsics} is successfull. The error type
  of the Runtime function is defined in Definition {\todo{define error type}}.
  
  \item {\tmname{Ready-Extrinsics-Queue}} indicates picking an extrinsics from
  the extrinsics queue (Definition \ref{defn-transaction-queue}).
  
  \item {\tmname{Drop}} indicates removing the extrinsic from the transaction
  queue (Definition \ref{defn-transaction-queue}).
\end{itemizeminus}
\section{Finality}\label{sect-finality}

Polkadot RE uses GRANDPA Finality protocol {\cite{stewart_grandpa:_2019}} to
finalize blocks. Finality is obtained by consecutive rounds of voting by
validator nodes. Validators execute GRANDPA finality process in parallel to
Block Production as an independent service. In this section, we describe the
different functions that GRANDPA service is supposed to perform to
successfully participate in the block finalization process.

\subsection{Preliminaries}

\begin{definition}
  A {\tmstrong{GRANDPA Voter}}, $v$, is represented by a key pair
  $(k^{\tmop{pr}}_v, v_{\tmop{id}})$ where $k_v^{\tmop{pr}}$ represents its
  private key which is an $\tmop{ED} 25519$ private key, is a node running
  GRANDPA protocol, and broadcasts votes to finalize blocks in a Polkadot RE -
  based chain. The {\tmstrong{set of all GRANDPA voters}} is indicated by
  $\mathbb{V}$. For a given block B, we have {\todo{change function name, only
  call at genesis, adjust V\_B over the sections}}
  \[ \mathbb{V}_B = \text{\tmverbatim{grandpa\_authorities}} (B) \]
  where $\mathtt{grandpa\_authorities}$ is the entry into runtime described in
  Section \ref{sect-rte-grandpa-auth}.
\end{definition}

\begin{definition}
  {\tmstrong{GRANDPA state}}, $\tmop{GS}$, is defined as {\todo{verify V\_id
  and id\_V usage, unify}}
  \[ \tmop{GS} \assign \{\mathbb{V}, \tmop{id}_{\mathbb{V}}, r\} \]
  where:
  
  $\mathbb{V}$: is the set of voters.
  
  {\tmstrong{$\mathbb{V}_{\tmop{id}}$}}: is an incremental counter tracking
  \tmverbatim{}membership, which changes in V.
  
  {\tmstrong{r}}: is the votin\tmverbatim{}g round number.
\end{definition}

Now we need to define how Polkadot RE counts the number of votes for block
$B$. First a vote is defined as:

\begin{definition}
  \label{defn-vote}A {\tmstrong{GRANDPA vote }}or simply a vote for block $B$
  is an ordered pair defined as
  \[ V_{\nosymbol} (B) \assign (H_h (B), H_i (B)) \]
  where $H_h (B)$ and $H_i (B)$ are the block hash and the block number
  defined in Definitions \ref{defn-block-header} and
  \ref{defn-block-header-hash} respectively.
\end{definition}

\begin{definition}
  Voters engage in a maximum of two sub-rounds of voting for each round $r$.
  The first sub-round is called {\tmstrong{pre-vote}} and\tmverbatim{} the
  second sub-round is called {\tmstrong{pre-commit}}.
  
  By {\tmstrong{$V_v^{r, \tmop{pv}}$}} and {\tmstrong{$V_v^{r, \tmop{pc}}$}}
  we refer to the vote cast by voter $v$ in round $r$ (for block $B$) during
  the pre-vote and the pre-commit sub-round respectively.
\end{definition}

The GRANDPA protocol dictates how an honest voter should vote in each
sub-round, which is described in Algorithm \ref{algo-grandpa-round}. After
defining what constitues a vote in GRANDPA, we define how GRANDPA counts
votes.

\begin{definition}
  Voter $v$ {\tmstrong{equivocates}} if they broadcast two or more valid votes
  to blocks not residing on the same branch of the block tree during one
  voting sub-round. In such a situation, we say that $v$ is an
  {\tmstrong{equivocator}} and any vote $V_v^{r, \tmop{stage}} (B)$ cast by
  $v$ in that round is an {\tmstrong{equivocatory vote}} and
  \[ \mathcal{E}^{r, \tmop{stage}} \]
  represents the set of all equivocators voters in sub-round
  ``$\tmop{stage}$'' of round $r$. When we want to refer to the number
  of\tmverbatim{} equivocators whose equivocation has been observed by voter
  $v$ we refer to it by:
  \[ \mathcal{E}^{r, \tmop{stage}}_{\tmop{obs} (v)} \]
  
\end{definition}

\begin{definition}
  A vote $V_v^{r, \tmop{stage}} = V (B)$ is {\tmstrong{invalid}} if
  \begin{itemize}
    \begin{itemizedot}
      \item $H (B)$ does not correspond to a valid block;
      
      \item $B$ is not an (eventual) descendant of a previously finalized
      block;
      
      \item $M^{r, \tmop{stage}}_v$ does not bear a valid signature;
      
      \item $\tmop{id}_{\mathbb{V}}$ does not match the current $\mathbb{V}$;
      
      \item If $V_v^{r, \tmop{stage}}$ is an equivocatory vote.
    \end{itemizedot}
  \end{itemize}
\end{definition}

\begin{definition}
  For validator v, {\tmstrong{the set of observed direct votes for Block $B$
  in round $r$}}, formally denoted by $\tmop{VD}^{r, \tmop{stage}}_{\tmop{obs}
  (v)}^{\nosymbol}_{\nosymbol} (B)$ is equal to the union of:
  \begin{itemizedot}
    \item set of valid votes $V^{r, \tmop{stage}}_{v_i}$ cast in round $r$ and
    received by v such that $V^{r, \tmop{stage}}_{v_i} = V (B)$.
  \end{itemizedot}
\end{definition}

\begin{definition}
  We refer to {\tmstrong{the set of total votes observed by voter $v$ in
  sub-round ``$\tmop{stage}$'' of round $r$}} by {\tmstrong{$V^{r,
  \tmop{stage}}_{\tmop{obs} (v)}^{\nosymbol}_{\nosymbol}$}}.
  
  The {\tmstrong{set of all observed votes by $v$ in the sub-round stage of
  round $r$ for block $B$}}, {\tmstrong{$V^{r, \tmop{stage}}_{\tmop{obs} (v)}
  (B)$}} is equal to all of the observed direct votes casted for block $B$ and
  all of the $B$'s descendents defined formally as:
  \[ V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) \assign \bigcup_{v_i \in
     \mathbb{V}, B \geqslant B'} \tmop{VD}^{r, \tmop{stage}}_{\tmop{obs} (v)}
     (B')_{\nosymbol}^{\nosymbol}_{\nosymbol} \]
  The {\tmstrong{total number of observed votes for Block $B$ in round $r$}}
  is defined to be the size of that set plus the total number of equivocators
  voters:
  \[ \#V^{r, \tmop{stage}}_{\tmop{obs} (v)} (B) = |V^{r,
     \tmop{stage}}_{\tmop{obs} (v)} (B) | + | \mathcal{E}^{r,
     \tmop{stage}}_{\tmop{obs} (v)} | \]
\end{definition}

\begin{definition}
  The current {\tmstrong{pre-voted}} block $B^{r, \tmop{pv}}_v$ is the block
  with
  \[ H_n (B^{r, \tmop{pv}}_v) = \tmop{Max} (H_n (B) | \forall B :
     \#V_{\tmop{obs} (v)}^{r, \tmop{pv}} (B) \geqslant 2 / 3|\mathbb{V}|) \]
\end{definition}

Note that for genesis state $\tmop{Genesis}$ we always have $\#V_{\tmop{obs}
(v)}^{r, \tmop{pv}} (B) = | \mathbb{V} |$.

\

Finally, we define when a voter $v$ see a round as completable, that is when
they are confident that $B_v^{r, \tmop{pv}}$ is an upper bound for what is
going to be finalised in this round. \

\begin{definition}
  \label{defn-grandpa-completable}We say that round $r$ is
  {\tmstrong{completable}} if $|V^{r, \tmop{pc}}_{\tmop{obs} (v)} |
  +\mathcal{E}^{r, \tmop{pc}}_{\tmop{obs} (v)} > \frac{2}{3} \mathbb{V}$ and
  for all $B' > B_v^{r, \tmop{pv}}$:
  \[ \begin{array}{l}
       |V^{r, \tmop{pc}}_{\tmop{obs} (v)} | -\mathcal{E}^{r,
       \tmop{pc}}_{\tmop{obs} (v)} - |V^{r, \tmop{pc}}_{\tmop{obs}
       (v)_{\nosymbol}} (B') | > \frac{2}{3} |\mathbb{V}|
     \end{array} \]
\end{definition}

Note that in practice we only need to check the inequality for those $B' >
B_v^{r, \tmop{pv}}$ where $|V^{r, \tmop{pc}}_{\tmop{obs} (v)_{\nosymbol}} (B')
| > 0$.

\

\subsection{Voting Messages Specification}

Voting is done by means of broadcasting voting messages to the network.
Validators inform their peers about the block finalized in round $r$ by
broadcasting a finalization message (see Algorithm \ref{algo-grandpa-round}
for more details). These messages are specified in this section.

\begin{definition}
  A vote casted by voter $v$ should be broadcasted as a {\tmstrong{message
  $M^{r, \tmop{stage}}_v$}} to the network by voter $v$ with the following
  structure:
  \[ M^{r, \tmop{stage}}_v \assign \tmop{Enc}_{\tmop{SC}} (r,
     \tmop{id}_{\mathbb{V}}, \tmop{Enc}_{\tmop{SC}} (\tmop{stage}, V_v^{r,
     \tmop{stage}}, \tmop{Sig}_{\tmop{ED} 25519} (\tmop{Enc}_{\tmop{SC}}
     (\tmop{stage}, V_v^{r, \tmop{stage}}, r, V_{\tmop{id}}), v_{\tmop{id}})
  \]
  Where:
  {\center{\begin{tabular}{rll}
    r: & round number & 64 bit integer\\
    $V_{\tmop{id}}$: & incremental change tracker counter & 64 bit integer\\
    {\rightaligned{$v_{\tmop{id}}$}}: & Ed25519 public key of $v$ & 32 byte
    array\\
    {\rightaligned{}}$\tmop{stage}$: & 0 if it is the pre-vote sub-round & 1
    byte\\
    & 1 if it the pre-commit sub-round & 
  \end{tabular}}}
  
\end{definition}

\begin{definition}
  \label{defn-grandpa-justification}The {\tmstrong{justification for block B
  in round $r$}} of GRANDPA protocol defined $J^r (B)$ is a vector of pairs of
  the type:
  \[ (V (B'), (\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B'), v_{\tmop{id}})) \]
  in which either
  \[ B' \geqslant B \]
  or $V^{r, \tmop{pc}}_{v_i} (B')$ is an equivocatory vote.
  
  In all cases, $\tmop{Sign}^{r, \tmop{pc}}_{v_i} (B')$ is the signature of
  voter $v_i$ broadcasted during the pre-commit sub-round of round r.
  
  We say $J^r (B)$ {\tmstrong{justifies the finalization}} of $B$ if the
  number of valid signatures in $J^r (B)$ is greater than $\frac{2}{3}
  |\mathbb{V}_B |$.
\end{definition}

\begin{definition}
  {\tmstrong{$\tmop{GRANDPA}$ finalizing message for block $B$ in round $r$}}
  represented as {\tmstrong{$M_v^{r, \tmop{Fin}}$(B)}} is a message
  broadcasted by voter $v$ to the network indicating that voter $v$ has
  finalized block $B$ in round $r$. It has the following structure:
  \[ M^{r, \tmop{Fin}}_v (B) \assign \tmop{Enc}_{\tmop{SC}} (r, V (B), J^r
     (B)) \]
  in which $J^r (B)$ in the justification defined in Definition
  \ref{defn-grandpa-justification}.
\end{definition}

\subsection{Initiating the GRANDPA State}

A validator needs to initiate its state and sync it with other validators, to
be able to participate coherently in the voting process. In particular,
considering that voting is happening in different rounds and each round of
voting is assigned a unique sequential round number $r_v$, it needs to
determine and set its round counter $r$ in accordance with the current voting
round $r_n$, which is currently undergoing in the network.

As instructed in Algorithm \ref{alg-join-leave-grandpa}, whenever the
membership of GRANDPA voters changes, $r$ is set to 0 and $V_{\tmop{id}}$
needs to be incremented.

\custombinding{14}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{14}}{\smallskip}
    
    \begin{tmindent}
      \label{alg-join-leave-grandpa}{\tmname{Join-Leave-Grandpa-Voters}}
      ($\mathcal{V}$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\subsection{Voting Process in Round $r$}

For each round $r$, an honest voter $v$ must participate in the voting process
by following Algorithm \ref{algo-grandpa-round}.

\custombinding{15}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{15}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-grandpa-round}{\tmname{Play-Grandpa-round}}$(r)$
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

The condition of {\tmem{completablitiy}} is defined in Definition
\ref{defn-grandpa-completable}. {\tmname{Best-Final-Candidate}} function is
explained in Algorithm \ref{algo-grandpa-best-candidate} and
{\tmname{{\tmname{Attempt-To-Finalize-Round}}($r$)}} is described in Algorithm
\ref{algo-attempt-tofinalize}.

\custombinding{16}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{16}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-grandpa-best-candidate}{\tmname{Best-Final-Candidate}}($r$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\custombinding{17}{\noindent}\begin{tmparmod}{0pt}{0pt}{0em}%
  \begin{tmparsep}{0em}%
    \tmtextbf{Algorithm \tmtextup{17}}{\smallskip}
    
    \begin{tmindent}
      \label{algo-attempt-tofinalize}{\tmname{Attempt-To-Finalize-Round}}($r$)
    \end{tmindent}
  \end{tmparsep}
\end{tmparmod}{\medskip}

\section{Block Finalization}\label{sect-block-finalization}

\begin{definition}
  \label{defn-finalized-block}A Polkadot relay chain node n should consider
  block $B$ as {\tmstrong{finalized}} if any of the following criteria holds
  for $B' \geqslant B$:
  \begin{itemize}
    \item $V^{r, \tmop{pc}}_{\tmop{obs} (n)}^{\nosymbol}_{\nosymbol} (B') > 2
    / 3 |\mathbb{V}_{B'} |$.
    
    \item it receives a $M_v^{r, \tmop{Fin}} (B')$ message in which $J^r (B)$
    justifies the finalization (according to Definition
    \ref{defn-grandpa-justification}).
    
    \item it receives a block data message for $B'$ with $\tmop{Just} (B')$
    defined in Section \ref{sect-justified-block-header} which justifies the
    finalization. 
  \end{itemize}
\end{definition}

for
\begin{itemizedot}
  \item any round $r$ if the node $n$ is {\tmem{not}} a GRANDPA voter.
  
  \item only for rounds $r$ for which the the node $n$ has invoked Algorithm
  \ref{algo-grandpa-round} if $n$ is a GRANDPA voter.
\end{itemizedot}
Note that all Polkadot relay chain nodes are supposed to listen to GRANDPA
finalizing messages regardless if they are GRANDPA
voters.\appendix\chapter{Cryptographic Algorithms}

\section{Hash Functions}\label{sect-hash-functions}

\section{BLAKE2}\label{sect-blake2}

BLAKE2 is a collection of cryptographic hash functions known for their high
speed. their design closely resembles BLAKE which has been a finalist in SHA-3
competition.

Polkadot is using Blake2b variant which is optimized for 64bit platforms.
Unless otherwise specified, Blake2b hash function with 256bit output is used
whenever Blake2b is invoked in this document. The detailed specification and
sample implementations of all variants of Blake2 hash functions can be found
in RFC 7693 {\cite{saarinen_blake2_2015}}.

\section{Randomness}\label{sect-randomness}

\section{VRF}\label{sect-vrf}

\section{Cryptographic Keys}\label{sect-cryptographic-keys}

Various types of keys are used in Polkadot to prove the identity of the actors
involved in Polkadot Protocols. To improve the security of the users, each key
type has its own unique function and must be treated differently, as described
by this section.

\begin{definition}
  \label{defn-account-key}{\tmstrong{Account key $(\tmop{sk}^a,
  \tmop{pk}^a)$}} is a key pair of type of either of schemes listed in Table
  \ref{tabl-account-key-schemes}:
  {\center{\begin{table}[h]
    \begin{tabular}{ll}
      \hline
      Key scheme & Description\\
      \hline
      SR25519 & Schnorr signature on Ristretto compressed Ed25519 points as
      implemented in {\cite{burdges_schnorr_2019}}\\
      ED25519 & The standard ED25519 signature complying with
      {\cite{josefsson_edwards-curve_2017}}\\
      secp256k1 & Only for outgoing transfer transactions\\
      \hline
    \end{tabular}
    \caption{\label{tabl-account-key-schemes}List of public key scheme which
    can be used for an account key}
  \end{table}}}
  Account key can be used to sign transactions among other accounts and
  blance-related functions.
\end{definition}

There are two prominent subcategories of account keys namely ``stash keys''
and ``controller keys'', each being used for a different function as described
below.

\begin{definition}
  The \label{defn-stash-key}{\tmstrong{Stash key}} is a type of an account key
  that holds funds bonded for staking (described in Section
  \ref{sect-staking-funds}) to a particular controller key (defined in
  Definition \ref{defn-controller-key}). As a result, one may actively
  participate with a stash key keeping the stash key offline in a secure
  location. It can also be used to designate a Proxy account to vote in
  governance proposals, as described in \ref{sect-creating-controller-key}.
  The Stash key holds the majority of the users' funds and should neither be
  shared with anyone, saved on an online device, nor used to submit
  extrinsics.
\end{definition}

\begin{definition}
  \label{defn-controller-key}The {\tmstrong{Controller key}} is a type of
  account key that acts on behalf of the Stash account. It signs transactions
  that make decisions regarding the nomination and the validation of other
  keys. It is a key that will be in the direct control of a user and should
  mostly be kept offline, used to submit manual extrinsics. It sets
  preferences like payout account and commission, as described in
  \ref{sect-controller-settings}. If used for a validator, it certifies the
  session keys, as described in \ref{sect-certifying-keys}. It only needs the
  required funds to pay transaction fees {\todo{key needing fund needs to be
  defined}}.
\end{definition}

Keys defined in Definitions \ref{defn-account-key}, \ref{defn-stash-key} and
\ref{defn-controller-key} are created and managed by the user independent of
the Polkadot implementation. The user notifies the network about the used keys
by submitting a transaction, as defined in \ref{sect-creating-controller-key}
and \ref{sect-certifying-keys} respectively.

\begin{definition}
  \label{defn-session-key}{\tmstrong{Session keys}} are short-lived keys that
  are used to authenticate validator operations. Session keys are generated by
  Polkadot RE and should be changed regularly due to security reasons.
  Nonetheless, no validity period is enforced by Polkadot protocol on session
  keys. Various types of keys used by Polkadot RE are presented in Table
  \ref{tabl-session-keys}{\tmem{:}}
  
  \begin{table}[h]
    \begin{tabular}{ll}
      \hline
      Protocol & Key scheme\\
      \hline
      GRANDPA & ED25519\\
      BABE & SR25519\\
      I'm Online & SR25519\\
      Parachain & SR25519\\
      \hline
    \end{tabular}
    \caption{\label{tabl-session-keys}List of key schemes which are used for
    session keys depending on the protocol}
  \end{table}
\end{definition}

Session keys must be accessible by certain Runtime Environment APIs defined in
Appendix \ref{sect-re-api}. Session keys are {\tmem{not}} meant to control the
majority of the users' funds and should only be used for their intended
purpose. {\todo{key managing fund need to be defined}}

\subsection{Holding and staking funds}\label{sect-staking-funds}

To be specced

\subsection{Creating a Controller key}\label{sect-creating-controller-key}

To be specced

\subsection{Designating a proxy for voting}\label{sect-designating-proxy}

To be specced

\subsection{Controller settings}\label{sect-controller-settings}

To be specced

\subsection{Certifying keys}\label{sect-certifying-keys}

Session keys should be changed regularly. As such, new session keys need to be
certified by a controller key before putting in use. The controller only needs
to create a certificate by signing a session public key and broadcastg this
certificate via an extrinsic. {\todo{spec the detail of the data structure of
the certificate etc.}}\chapter{Auxiliary Encodings}\label{sect-encoding}

\section{SCALE Codec}\label{sect-scale-codec}

Polkadot RE uses {\tmem{Simple Concatenated Aggregate Little-Endian'' (SCALE)
codec}} to encode byte arrays as well as other data structures. SCALE provides
a canonical encoding to produce consistent hash values across their
implementation, including the Merkle hash proof for the State Storage.

\begin{definition}
  \label{defn-scale-byte-array}The {\tmstrong{SCALE codec}} for
  {\tmstrong{Byte array}} $A$ such that
  \[ A \assign b_1 b_2 \ldots b_n \]
  such that $n < 2^{536}$ is a byte array refered to $\tmop{Enc}_{\tmop{SC}}
  (A)$ and defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| A \|) | | A \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}. 
\end{definition}

\begin{definition}
  \label{defn-scale-tuple}The {\tmstrong{SCALE codec}} for {\tmstrong{Tuple}}
  $T$ such that:
  \[ T \assign (A_1, \ldots, A_n) \]
  Where $A_i$'s are values of {\tmstrong{different types}}, is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (T) \assign \tmop{Enc}_{\tmop{SC}} (A_1) | |
     \tmop{Enc}_{\tmop{SC}} (A_2) | | \ldots | | \tmop{Enc}_{\tmop{SC}} (A_n)
  \]
\end{definition}

In case of a tuple (or struct), the knowledge of the shape of data is not
encoded even though it is necessary for decoding. The decoder needs to derive
that information from the context where the encoding/decoding is happenning.

\begin{definition}
  \label{defn-varrying-data-type}We define a {\tmstrong{varying data}} type to
  be an ordered set of data types
  \[ \mathcal{T}= \{ T_1, \ldots, T_n \} \]
  A value $\tmmathbf{A}$ of varying date type is a pair $(A_{\tmop{Type}},
  A_{\tmop{Value}})$ where $A_{\tmop{Type}} = T_i$ for some $T_i \in
  \mathcal{T}$ and $A_{\tmop{Value}}$ is its value of type $T_i$, which can be
  empty. We define $\tmop{idx} (T_i) = i - 1$, unless it is explicitly defined
  as another value in the definition of a particular varying data type.
\end{definition}

In particular, we define two specific varying data which are frequently used
in various part of Polkadot Protocol.

\begin{definition}
  $\label{defn-option-type}$The {\tmstrong{Option}} type is a varying data
  type of $\{\tmop{None}, T_2 \}$ which indicates if data of $T_2$ type is
  available (referred to as ``some'' state) or not (referred to as ``empty'',
  ``none'' or ``null'' state). The presence of type None, indicated by
  $\tmop{idx} (T_{\tmop{None}}) = 0$, implies that the data corresponding to
  $T_2$ type is not available and contains no additional data. Where as the
  presence of type $T_2$ indicated by $\tmop{idx} (T_2) = 1$ implies that the
  data is available.
\end{definition}

\begin{definition}
  \label{defn-result-type}The {\tmstrong{Result}} type is a varying data type
  of $\{ T_1, T_2 \}$ which is used to indicate if a certain operation or
  function was executed successfully (referred to as ``ok'' state) or not
  (referred to as ``err'' state). $T_1$ implies success, $T_2$ implies
  failure. Both types can either contain additional data or are defined as
  empty type otherwise.
\end{definition}

\begin{definition}
  \label{defn-scale-variable-type}Scale coded for value {\tmstrong{$A =
  (A_{\tmop{Type}}, A_{\tmop{Value}})$ of varying data type}} $\mathcal{T}= \{
  T_1, \ldots, T_n \}$
  \[ \tmop{Enc}_{\tmop{SC}} (A) \assign \tmop{Enc}_{\tmop{SC}} (\tmop{Idx}
     (A_{\tmop{Type}})) | | \tmop{Enc}_{\tmop{SC}} (A_{\tmop{Value}}) \]
  Where $\tmop{Idx}$ is encoded in a fixed length integer determining the type
  of $A$.
  
  In particular, for the optional type defined in Definition
  \ref{defn-varrying-data-type}, we have:
  \[ \tmop{Enc}_{\tmop{SC}} ((\tmop{None}, \phi)) \assign 0_{\mathbb{B}_1} \]
\end{definition}

SCALE codec does not encode the correspondence between the value of
$\tmop{Idx}$ defined in Definition \ref{defn-scale-variable-type} and the data
type it represents; the decoder needs prior knowledge of such correspondence
to decode the data.

\begin{definition}
  \label{defn-scale-list}The {\tmstrong{SCALE codec}} for
  {\tmstrong{sequence}} $S$ such that:
  \[ S \assign A_1, \ldots, A_n \]
  where $A_i$'s are values of {\tmstrong{the same type}} (and the decoder is
  unable to infer value of $n$ from the context) is defined as:
  \[ \tmop{Enc}_{\tmop{SC}} (S) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| S \|) \tmop{Enc}_{\tmop{SC}} (A_1) | \tmop{Enc}_{\tmop{SC}} (A_2) |
     \ldots | \tmop{Enc}_{\tmop{SC}} (A_n) \]
  where $\tmop{Enc}_{\tmop{SC}}^{\tmop{Len}}$ is defined in Definition
  \ref{defn-sc-len-encoding}. SCALE codec for {\tmstrong{dictionary}} or
  {\tmstrong{hashtable}} D with key-value pairs $(k_i, v_i)$s such that:
  \[ D \assign \{ (k_1, v_1), \ldots, (k_1, v_n) \} \]
  is defined the SCALE codec of $D$ as a sequence of key value pairs (as
  tuples):
  \[ \tmop{Enc}_{\tmop{SC}} (D) \assign \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}
     (\| D \|) \tmop{Enc}_{\tmop{SC}} ((k_1, v_1)_{}) | \tmop{Enc}_{\tmop{SC}}
     ((k_2, v_2)) | \ldots | \tmop{Enc}_{\tmop{SC}} ((k_n, v_n)) \]
  \[ \  \]
\end{definition}

\begin{definition}
  The {\tmstrong{SCALE codec}} for {\tmstrong{boolean value}} $b$ defined as a
  byte as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}_{\tmop{SC}} : & \{ \tmop{False}, \tmop{True} \} \rightarrow
       \mathbb{B}_1\\
       & b \rightarrow \left\{ \begin{array}{lcl}
         0 &  & b = \tmop{False}\\
         1 &  & b = \tmop{True}
       \end{array} \right.
     \end{array} \]
\end{definition}

\begin{definition}
  \label{defn-scale-fixed-length}The {\tmstrong{SCALE codec,
  $\tmop{Enc}_{\tmop{SC}}$}} for other types such as fixed length integers not
  defined here otherwise, is equal to little endian encoding of those values
  defined in Definition \ref{defn-little-endian}. 
\end{definition}

\begin{definition}
  \label{defn-scale-empty}The {\tmstrong{SCALE codec,
  $\tmop{Enc}_{\tmop{SC}}$}} for an empty type is defined to a byte array of
  zero length and depicted as {\tmstrong{$\phi$}}.
\end{definition}

\subsection{Length and Compact Encoding}\label{sect-int-encoding}

{\tmem{SCALE Length encoding}} is used to encode integer numbers of variying
sizes prominently in an encoding length of arrays:

\begin{definition}
  \label{defn-sc-len-encoding}{\tmstrong{SCALE Length Encoding,
  $\tmop{Enc}^{\tmop{Len}}_{\tmop{SC}}$}} also known as compact encoding of a
  non-negative integer number $n$ is defined as follows:
  \[ \begin{array}{ll}
       \tmop{Enc}^{\tmop{Len}}_{\tmop{SC}} : & \mathbb{N} \rightarrow
       \mathbb{B}\\
       & n \rightarrow b \assign \left\{ \begin{array}{lll}
         l^{\nosymbol}_1 &  & 0 \leqslant n < 2^6\\
         i^{\nosymbol}_1 i^{\nosymbol}_2 &  & 2^6 \leqslant n < 2^{14}\\
         j^{\nosymbol}_1 j^{\nosymbol}_2 j_3 &  & 2^{14} \leqslant n <
         2^{30}\\
         k_1^{\nosymbol} k_2^{\nosymbol} \ldots k_m^{\nosymbol}  &  & 2^{30}
         \leqslant n
       \end{array} \right.
     \end{array} \]
  in where the least significant bits of the first byte of byte array b are
  defined as follows:
  \[ \begin{array}{lcc}
       l^1_1 l_1^0 & = & 00\\
       i^1_1 i_1^0 & = & 01\\
       j^1_1 j_1^0 & = & 10\\
       k^1_1 k_1^0 & = & 11
     \end{array} \]
  and the rest of the bits of $b$ store the value of $n$ in little-endian
  format in base-2 as follows:
  \[ \left. \begin{array}{lll}
       l^7_1 \ldots l^3_1 l^2_1 &  & n < 2^6\\
       i_2^7 \ldots i_2^0 i_1^7 \ldots i^2_1^{\nosymbol} &  & 2^6 \leqslant n
       < 2^{14}\\
       j_4^7 \ldots j_4^0 j_3^7 \ldots j_1^7 \ldots j^2_1 &  & 2^{14}
       \leqslant n < 2^{30}\\
       k_2 + k_3 2^8 + k_4 2^{2 \cdummy 8} + \cdots + k_m 2^{(m - 2) 8} &  &
       2^{30} \leqslant n
     \end{array} \right\} \assign n \]
  such that:
  \[ k^7_1 \ldots k^3_1 k^2_1 : = m - 4 \]
\end{definition}

\section{Hex Encoding}

Practically, it is more convenient and efficient to store and process data
which is stored in a byte array. On the other hand, the Trie keys are broken
into 4-bits nibbles. Accordingly, we need a method to encode sequences of
4-bits nibbles into byte arrays canonically:

\begin{definition}
  \label{defn-hex-encoding}Suppose that $\tmop{PK} = (k_1, \ldots, k_n)$ is a
  sequence of nibbles, then
  
  \begin{tabular}{l}
    $\tmop{Enc}_{\tmop{HE}} (\tmop{PK}) \assign$\\
    $\left\{ \begin{array}{lll}
      \tmop{Nibbles}_4 & \rightarrow & \mathbb{B}\\
      \tmop{PK} = (k_1, \ldots, k_n) & \mapsto & \left\{ \begin{array}{l}
        \begin{array}{ll}
          (16 k_1 + k_2, \ldots, 16 k_{2 i - 1} + k_{2 i}) & n = 2 i\\
          (k_1, 16 k_2 + k_3, \ldots, 16 k_{2 i} + k_{2 i + 1}) & n = 2 i + 1
        \end{array}
      \end{array} \right.
    \end{array} \right.$
  \end{tabular}
\end{definition}

\

\chapter{Genesis State Specification}\label{sect-genesis-block}

The genesis state represents the intial state of Polkadot state storage as a
set of key-value pairs, which can be retrieved from
{\cite{web3.0_technologies_foundation_polkadot_2020}}. While each of those
key/value pairs offer important identifyable information which can be used by
the Runtime, from Polkadot RE points of view, it is a set of arbitrary
key-value pair data as it is chain and network dependent. \ Except for the
\tmverbatim{:code} described in Section \ref{sect-loading-runtime-code} which
needs to be identified by the Polkadot RE to load its content as the Runtime.
The other keys and values are unspecifed and its usage depends on the chain
respectively its corresponding Runtime. The data should be inserted into the
state storage with the \tmverbatim{set\_storage} RE API, as defined in Section
\ref{sect-set-storage}.

As such, Polkadot does not defined a formal genesis block. Nonetheless for the
complatibilty reasons in several algorithms, Polkadot RE defines the
{\tmem{genesis header}} according to Definition \ref{defn-genesis-header}. By
the abuse of terminalogy, ``{\tmem{genesis block}}'' refers to the
hypothetical parent of block number 1 which holds genisis header as its
header.

\begin{definition}
  \label{defn-genesis-header}The Polkadot genesis header is a data structure
  conforming to block header format described in section
  \ref{defn-block-header}. It contains the values depicted in Table
  \ref{tabl-genesis-header}:
  
  \begin{table}[h]
    \begin{tabular}{ll}
      \hline
      Block header field & Genesis Header Value\\
      \hline
      \tmverbatim{}{\tmsamp{parent\_hash}} & 0\\
      {\tmsamp{number}} & 0\\
      \tmverbatim{state\_root} & Merkle hash of the state storage trie as
      defined in Definition \ref{defn-merkle-value} \\
      & after inserting the genesis state in it.\\
      {\tmsamp{extrinsics\_root}} & 0\\
      {\tmsamp{digest}} & 0\\
      \hline
    \end{tabular}
    \caption{\label{tabl-genesis-header}Genesis header values}
  \end{table}
\end{definition}

\chapter{Network Messages}\label{sect-network-messages}

In this section, we will specify various types of messages which Polkadot RE
receives from the network. Furthermore, we also explain the appropriate
responses to those messages.

\begin{definition}
  A {\tmstrong{network message}} is a byte array, {\tmstrong{$M$}} of length
  $\| M \|$ such that:
  
  
  \[ \begin{array}{cc}
       M_1 & \tmop{Message} \tmop{Type} \tmop{Indicator}\\
       M_2 \ldots M_{\| M \|} & \tmop{Enc}_{\tmop{SC}} (\tmop{MessageBody})
     \end{array} \]
  
\end{definition}

The body of each message consists of different components based on its type.
The different possible message types are listed below in Table
\ref{tabl-message-types}. We describe the sub-components of each message type
individually in Section \ref{sect-message-detail}.

\begin{table}[h]
  \begin{tabular}{|c|c|c|}
    \hline
    $M_1$ & Message Type & Description\\
    \hline
    0 & Status & \ref{sect-msg-status}\\
    1 & Block Request & \ref{sect-msg-block-request}\\
    2 & Block Response & \ref{sect-msg-block-response}\\
    3 & Block Announce & \ref{sect-msg-block-announce}\\
    4 & Transactions & \ref{sect-msg-transactions}\\
    5 & Consensus & \ref{sect-msg-consensus}\\
    6 & Remote Call Request & \\
    7 & Remote Call Response & \\
    8 & Remote Read Request & \\
    9 & Remote Read Response & \\
    10 & Remote Header Request & \\
    11 & Remote Header Response & \\
    12 & Remote Changes Request & \\
    13 & Remote Changes Response & \\
    14 & FinalityProofRequest & \\
    15 & FinalityProofResponse & \\
    255 & Chain Specific & \\
    \hline
  \end{tabular}
  \caption{\label{tabl-message-types}List of possible network message types.}
\end{table}

\section{Detailed Message Structure}\label{sect-message-detail}

This section disucsses the detailed structure of each network message.

\subsection{Status Message}\label{sect-msg-status}

A {\tmem{Status}} Message represented by $M_S$ is sent after a connection with
a neighbouring node is established and has the following structure:
\[ M^{}_S \assign \tmop{Enc}_{\tmop{SC}} (v, r, N_B, \tmop{Hash}_B,
   \tmop{Hash}_G, C_S) \]
Where:
{\center{\begin{tabular}{rll}
  $v$: & Protocol version & 32 bit integer\\
  $v_{\min} :$ & Minimum supported version & 32 bit integer\\
  $r$: & Roles & 1 byte\\
  $N_B$: & Best Block Number & 64 bit integer\\
  $\tmop{Hash}_B$ & Best block Hash & $\mathbb{B}_{32}$\\
  $\tmop{Hash}_G$ & Genesis Hash & $\mathbb{B}_{32}$\\
  $C_S$ & Chain Status & Byte array 
\end{tabular}}}


In which, Role is a bitmap value whose bits represent different roles for the
sender node as specified in Table \ref{tabl-node-role}:

\

\begin{center}
  \tmfloat{h}{small}{table}{
  {\center{\begin{tabular}{|r|l|l|}
    \hline
    Value & Binary representation & Role\\
    \hline
    $0$ & 00000000 & No network\\
    1 & 00000001 & Full node, does not participate in consensus\\
    2 & 00000010 & Light client node\\
    4 & 00000100 & Act as an authority \\
    \hline
  \end{tabular}}}
  }{\label{tabl-node-role}Node role representation in the status message.}
\end{center}

\subsection{Block Request Message}\label{sect-msg-block-request}

A Block request message, represented by $M_{\tmop{BR}}$, is sent to request
block data for a range of blocks from a peer and has the following structure:
\[ M^{}_{\tmop{BR}} \assign \tmop{Enc}_{\tmop{SC}} (\tmop{id}, A_B, S_B,
   \tmop{Hash}_E, d, \tmop{Max}) \]
where:
{\center{\begin{tabular}{rll}
  $\tmop{id}$: & Unique request id & 32 bit integer\\
  $A_B$: & Requested data & 1 byte\\
  $S_B$: & Starting Block & Varying \{$\mathbb{B}_{32}, 64 \tmop{bit}
  \tmop{integer}$\}\\
  $\tmop{Hash}_E$ & End block Hash & $\mathbb{B}_{32}$ optional type\\
  $d$ & Block sequence direction & 1 byte\\
  $\tmop{Max}$ & Maximum number of blocks to return & 32 bit integer optional
  type
\end{tabular}}}


\

in which
\begin{itemizeminus}
  \item $A_B$, the requested data, is a bitmap value, whose bits represent the
  part of the block data requested, as explained in Table
  \ref{tabl-block-attributes}:
\end{itemizeminus}
\begin{center}
  \tmfloat{h}{small}{table}{
  {\center{\begin{tabular}{|r|l|l|}
    \hline
    Value & Binary representation & Requested Attribute\\
    \hline
    $1$ & 00000001 & Block header\\
    2 & 00000010 & Block Body\\
    4 & 00000100 & Receipt\\
    8 & 00001000 & Message queue\\
    16 & 00010000 & Justification \\
    \hline
  \end{tabular}}}
  }{\label{tabl-block-attributes}Bit values for block attribute $A_B$, to
  indicate the requested parts of the data.}
\end{center}
\begin{itemizeminus}
  \item $S_B$ is SCALE encoded varying data type (see Definition
  \ref{defn-scale-variable-type}) of either $\mathbb{B}_{32}$ representing the
  block hash, $H_B$, or $64 \tmop{bit}$ integer representing the block number
  of the starting block of the requested range of blocks.
  
  \item $\tmop{Hash}_E$ is optionally the block hash of the last block in the
  range.
  
  \item $d$ is a flag; it defines the direction on the block chain where the
  block range should be considered (starting with the starting block), as
  follows
  \[ d = \left\{ \begin{array}{cc}
       0 & \tmop{child} \tmop{to} \tmop{parent} \tmop{direction}\\
       1 & \tmop{parent} \tmop{to} \tmop{child} \tmop{direction}
     \end{array} \right. \]
\end{itemizeminus}
Optional data type is defined in Definition \ref{defn-varrying-data-type}.

\subsection{Block Response Message}\label{sect-msg-block-response}

A {\tmem{block response message}} represented by $M_{\tmop{BS}}$ is sent in a
response to a requested block message (see Section
\ref{sect-msg-block-request}). It has the following structure:
\[ M^{}_{\tmop{BS}} \assign \tmop{Enc}_{\tmop{SC}} (\tmop{id}, D) \]
where:
{\center{\begin{tabular}{rll}
  $\tmop{id}$: & Unique id of the requested response was made for & 32 bit
  integer\\
  $D$: & Block data for the requested sequence of Block & Array of block data
\end{tabular}}}


\

In which block data is defined in Definition \ref{defn-block-data}.

\begin{definition}
  \label{defn-block-data}{\tmstrong{Block Data}} is defined as the follownig
  tuple:{\todo{Block Data definition should go to block format section}}
\end{definition}
\[ (H_B, \tmop{Header}_B, \tmop{Body}, \tmop{Receipt}, \tmop{MessageQueue},
   \tmop{Justification}) \]
Whose elements, with the exception of $H_B$, are all of the following
{\tmem{optional type}} (see Definition \ref{defn-varrying-data-type}) and are
defined as follows:
{\center{\begin{tabular}{rll}
  $H_B$: & Block header hash & $\mathbb{B}_{32}$\\
  $\tmop{Header}_B$: & Block header & 5-tuple (Definition
  \ref{defn-block-header})\\
  Body & Array of extrinsics & Array of Byte arrays (Section
  \ref{sect-extrinsics})\\
  Receipt & Block Receipt & Byte array\\
  Message Queue & Block message queue & Byte array\\
  Justification & Block Justification & Byte array
\end{tabular}}}


\subsection{Block Announce Message}\label{sect-msg-block-announce}

A {\tmem{block announce message}} represented by $M_{\tmop{BA}}$ is sent when
a node becomes aware of a new complete block on the network and has the
following structure:
\[ M_{\tmop{BA}} \assign \tmop{Enc}_{\tmop{SC}} (\tmop{Header}_B) \]
Wh\tmverbatim{}ere:
{\center{\begin{tabular}{rll}
  $\tmop{Header}_B$: & Header of new block B & 5-tuple header (Definition
  \ref{defn-block-header})
\end{tabular}}}
\subsection{Transactions}\label{sect-msg-transactions}

\ \ \ The transactions Message is represented by $M_T$ and is defined as
follows:
\[ M_T \assign \tmop{Enc}_{\tmop{SC}} (C_1, \ldots, C_n) \]
in which:
\[ C_i \assign \tmop{Enc}_{\tmop{SC}} (E_i) \]
Where each $E_i$ is a byte array and represents a sepearate extrinsic.
Polkadot RE is indifferent about the content of an extrinsic and treats it as
a blob of data.

\subsection{Consensus Message}\label{sect-msg-consensus}

A {\tmem{consensus message}} represented by $M_C$ is sent to communicate
messages related to consensus process:
\[ M_C \assign \tmop{Enc}_{\tmop{SC}} (E_{\tmop{id}}, D) \]
Wh\tmverbatim{}ere:
{\center{\begin{tabular}{rll}
  $E_{\tmop{id}}$: & The consensus engine unique identifier & $\mathbb{B}_4$\\
  $D$ & Consensus message payload & $\mathbb{B}$
\end{tabular}}}


in which
\[ E_{\tmop{id}} \assign \left\{ \begin{array}{ccc}
     '' \tmop{BABE}'' &  & \tmop{For} \tmop{messages} \tmop{related} \tmop{to}
     \tmop{BABE} \tmop{protocol} \tmop{refered} \tmop{to} \tmop{as}
     E_{\tmop{id}} (\tmop{BABE})\\
     '' \tmop{FRNK}'' &  & \tmop{For} \tmop{messages} \tmop{related} \tmop{to}
     \tmop{GRANDPA} \tmop{protocol} \tmop{referred} \tmop{to} \tmop{as}
     E_{\tmop{id}} (\tmop{FRNK})
   \end{array} \right. \]


The network agent should hand over $D$ to approperiate consensus engine which
identified by $E_{\tmop{id}}$.

\

\chapter{Runtime Environment API}\label{appendix-e}

The Runtime Environment API is a set of functions that Polkadot RE exposes to
Runtime to access external functions needed for various reasons, such as the
Storage of the content, access and manipulation, memory allocation, and also
efficiency. The encoding of each data type is specified or referenced in this
section. If the encoding is not mentioned, then the default Wasm encoding is
used, such as little-endian byte ordering for integers.

\begin{notation}
  \label{nota-re-api-at-state}By $\mathcal{R}\mathcal{E}_B$ we refer to the
  API exposed by Polkadot RE which interact, manipulate and response based on
  the state storage whose state is set at the end of the execution of block
  $B$.
\end{notation}

\begin{definition}
  \label{defn-runtime-pointer}The {\tmstrong{Runtime pointer-size}} type is an
  \tmverbatim{i64} integer, representing two consecutive \tmverbatim{i32}
  integers in which the least significant one indicates the pointer to the
  memory buffer. The most significant one provides the size of the buffer.
  This pointer is the primary way to exchange data of arbitrary sizes between
  the Runtime and the Runtime Environment.
\end{definition}

The functions are specified in each subsequent subsection for each category
of those functions.

\section{Storage}

Interface for accessing the storage from within the runtime.

\subsection{\tmverbatim{ext\_storage\_set}}

Sets the value under a given key into storage.

\subsubsection{Version 1 - Prototype}


\begin{alltt}
(func $ext_storage_set_version_1 (param $key i64) (param $value i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the key.
  
  \item \tmverbatim{value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the value.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_get}}

Retrieves the value associated with the given key from storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_get_version_1 (param $key i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the key.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} returning the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the value.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_read}}

Gets the given key from storage, placing the value into a buffer and returning
the number of bytes that the entry in storage has beyond the offset.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_read_version_1
  (param $key i64) (param $value_out i64) (param $offset i32) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the key.
  
  \item \tmverbatim{value\_out}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the buffer to which the value will be
  written to. This function will never write more then the length of the
  buffer, even if the value's length is bigger.
  
  \item \tmverbatim{offset}: an i32 integer containing the offset beyond the
  value should be read from.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the number of
  bytes written into the \tmverbatim{value\_out} buffer. Returns
  \tmverbatim{None} if the entry does not exists.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_clear}}

Clears the storage of the given key and its value.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_clear_version_1 (param $key_data i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the key.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_exists}}

Checks whether the given key exists in storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_exists_version_1 (param $key_data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the key.
  
  \item \tmverbatim{return}: an i32 integer value equal to \tmverbatim{1} if
  the key exists or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_clear\_prefix}}

Clear the storage of each key/value pair where the key starts with the given
prefix.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_clear_prefix_version_1 (param $prefix i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{prefix}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} containing the prefix.
\end{itemize}
\subsection{\tmverbatim{ext\_storage\_root}}\label{sect-ext-storage-root}

Computes the resulting storage root as described in section
\ref{sect-merkl-proof}.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_root_version_1 (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded storage root.
\end{itemize}
\subsection{\tmverbatim{ext\_storage\_changes\_root}}\label{sect-ext-storage-changes-root}

Generates the resulting changes root as defined in Definition
\ref{defn-changes-trie}. The parent hash is a SCALE encoded block hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_changes_root_version_1 (param $parent_hash i64) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{parent\_hash}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the SCALE encoded block
  hash.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the changes root
  as defined in Definition \ref{defn-changes-trie}.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_next\_key}}

Gets the next key in storage after the given one in lexicographic order.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_next_key_version_1 (param $key i64) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the next key in
  lexicographic order.
\end{itemize}

\section{Child Storage}

Interface for accessing the child storage from within the runtime.

\begin{definition}
  \label{defn-child-storage-type}{\tmstrong{Child storage}} key is the
  identifier for the child storage. Multiple child storages are possible,
  where it's corresponding entries are separated based on the identifier. The
  prefix \tmverbatim{:child\_storage:default:} must be prepended to the
  identiefier.
\end{definition}

\begin{definition}
  {\tmstrong{\label{defn-child-storage-definition}Child storage definition}}
  allows for further separation from within the child storage, behaving like a
  prefix. When a key gets set in the child storage using a certain definition,
  the same definition must be used in order to fetch the key or perform other
  operations on it. The value of the definition is undefined and set by the
  Runtime.
\end{definition}

\begin{definition}
  \label{defn-child-type}{\tmstrong{Child type}} is a future-reserved feature
  which allows the usage of different child storage types. The currently
  allowed value is an i32 integer equal to {\tmstrong{1}}.
\end{definition}

\subsection{\tmverbatim{ext\_storage\_child\_set}}

Sets the value under a given key into the child storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_set_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (param $key i64) (param $value i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child definition as
  described in Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in \ref{defn-child-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the value.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_child\_get}}

Retrieves the value associated with the given key from the child storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_get_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (param $key i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child definition as
  described in Defnition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in Definition \ref{defn-child-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the value.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_child\_read}}

Gets the given key from storage, placing the value into a buffer and returning
the number of bytes that the entry in storage has beyond the offset.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_read_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (param $key i64) (param $value_out i64) (param $offset i32) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer as defined in Defintion
  \ref{defn-runtime-pointer} indicating the child definition as described in
  Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in Definition \ref{defn-child-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{value\_out}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the buffer to which the value will be
  written to. This function will never write more then the length of the
  buffer, even if the value's length is bigger.
  
  \item \tmverbatim{offset}: an i32 integer containing the offset beyond the
  value should be read from.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the number of
  bytes written into the {\tmstrong{value\_out}} buffer. Returns
  \tmverbatim{None} if the entry does not exists.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_child\_clear}}

Clears the storage of the given key and its value from the child storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_clear_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (param $key i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child definition as
  described in Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in \ref{defn-child-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_child\_storage\_kill}}

Clears an entire child storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_storage_kill_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child definition as
  described in Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in Definition \ref{defn-child-type}.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_child\_exists}}

Checks whether the given key exists in the child storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_exists_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (param $key_data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Defintion \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child definition as
  described in Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in Defintion \ref{defn-child-type}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{return}: an i32 integer value equal to \tmverbatim{1} if
  the key exists or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_child\_clear\_prefix}}

Clears the child storage of each key/value pair where the key starts with the
given prefix.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_clear_prefix_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (param $prefix i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child definition as
  described in Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in Definition \ref{defn-child-type}.
  
  \item \tmverbatim{prefix}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the prefix.
\end{itemize}
\subsection{\tmverbatim{ext\_storage\_child\_root}}\label{sect-ext-storage-child-root}

Computes the resulting child storage root as described in section
\ref{sect-merkl-proof}.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_root_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child definition as
  described in Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in Definition \ref{defn-child-type}.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded storage root.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_child\_next\_key}}

Gets the next key in storage after the given one in lexicographic order.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_storage_child_next_key_version_1
  (param $child_storage_key i64) (param $child_definition i64) (param $child_type i32)
  (param $key i64) (return i64))
\end{alltt}


{\tmstrong{\tmverbatim{}Arguments}}:
\begin{itemize}
  \item \tmverbatim{child\_storage\_key}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the child storage key as
  defined in Definition \ref{defn-child-storage-type}.
  
  \item \tmverbatim{child\_definition}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicting the child definition as
  described in Definition \ref{defn-child-storage-definition}.
  
  \item \tmverbatim{child\_type}: an i32 integer specifying the child storage
  type as defined in Definition \ref{defn-child-type}.
  
  \item {\tmstrong{}}\tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the next key in
  lexicographic order. Returns \tmverbatim{None} if the entry cannot be found.
\end{itemize}

\section{Crypto}

Interfaces for working with crypto related types from within the runtime.

\begin{definition}
  \label{defn-key-type-id}Cryptographic keys are saved in their own storages
  in order to avoid collision with each other. The storages are identified by
  their 4-byte ASCII {\tmstrong{key type ID}}. The following known types are
  available:
  
  \begin{table}[h]
    \begin{tabular}{ll}
      {\tmstrong{Id}} & {\tmstrong{Description}}\\
      babe & Key type for the Babe module\\
      gran & Key type for the Grandpa module\\
      acco & Key type for the controlling accounts\\
      imon & Key type for the ImOnline module\\
      audi & Key type for the AuthorityDiscovery module
    \end{tabular}
    \caption{Table of known key type identifiers}
  \end{table}
\end{definition}

\begin{definition}
  \label{defn-ecdsa-verify-error}{\tmstrong{EcdsaVerifyError}} is a varying
  data type as defined in Definition \ref{defn-varrying-data-type} and
  specifies the error type when using ECDSA recovery functionality. Following
  values are possible:
  
  \begin{table}[h]
    \begin{tabular}{ll}
      {\tmstrong{Id}} & {\tmstrong{Description}}\\
      0 & Incorrect value of R or S\\
      1 & Incorrect value of V\\
      2 & Invalid signature
    \end{tabular}
    \caption{Table of error types in ECDSA recovery}
  \end{table}
\end{definition}

\subsection{\tmverbatim{ext\_crypto\_ed25519\_public\_keys}}

Returns all \tmverbatim{ed25519} public keys for the given key id from the
keystore.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_ed25519_public_keys_version_1 (param $key_type_id i64) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: an i32 integer indicating the
  key type ID as defined in Defintion \ref{defn-key-type-id}.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded 32-byte public keys.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ed25519\_generate}}

Generates an \tmverbatim{ed25519} key for the given key type using an optional
BIP-39 seed and stores it in the keystore.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_ed25519_generate_version_1
  (param $key_type_id i32) (param $seed i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: an i32 integer indicating the
  key type ID as defined in Definition \ref{defn-key-type-id}.
  
  \item \tmverbatim{seed}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the BIP-39 seed
  which must be valid UTF8.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  32-byte public key.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ed25519\_sign}}

Signs the given message with the ed25519 key that corresponds to the given
public key and key type in the keystore.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_ed25519_sign_version_1
  (param $key_type_id i32) (param $key i32) (param $msg i64) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: an i32 integer indicating the
  key type ID as defined in Definition \ref{defn-key-type-id}.
  
  \item \tmverbatim{key}: a regular pointer to the buffer containing the
  32-byte public key.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the message that is to be signed.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the signature.
  This function returns \tmverbatim{None} if the public key cannot be found in
  the key store.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_ed25519\_verify}}

Verifies an ed25519 signature.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_ed25519_verify_version_1
  (param $sig i32) (param $msg i64) (param $key i32) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a regular pointer to the buffer
  containing the 64-byte signature.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the message that is to be verified.
  
  \item \tmverbatim{key}: a regular pointer to the buffer containing the
  32-byte public key.
  
  \item \tmverbatim{return}: a i32 integer value equal to \tmverbatim{1} if
  the signature is valid or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_sr25519\_public\_keys}}

Returns all \tmverbatim{sr25519} public keys for the given key id from the
keystore.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_sr25519_public_keys_version_1 (param $key_type_id i64) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: an i32 integer containg the
  key type ID as defined in \ref{defn-key-type-id}.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded 32-byte public keys.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_sr25519\_generate}}

Generates an \tmverbatim{sr25519} key for the given key type using an optional
BIP-39 seed and stores it in the keystore.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_sr25519_generate_version_1
  (param $key_type_id i32) (param $seed i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: an i32 integer containg the
  key ID as defined in Definition \ref{defn-key-type-id}.
  
  \item \tmverbatim{seed}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the BIP-39 seed
  which must be valid UTF8.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  32-byte public key.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_sr25519\_sign}}

Signs the given message with the \tmverbatim{sr25519} key that corresponds to
the given public key and key type in the keystore.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_sr25519_sign_version_1
  (param $key_type_id i32) (param $key i32) (param $msg i64) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{key\_type\_id}: an i32 integer containg the
  key ID as defined in Definition \ref{defn-key-type-id}
  
  \item \tmverbatim{key}: a regular pointer to the buffer containing the
  32-byte public key.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the message that is to be signed.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the signature.
  This function returns \tmverbatim{None} if the public key cannot be found in
  the key store.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_sr25519\_verify}}

Verifies an \tmverbatim{sr25519} signature.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_sr25519_verify_version_1
  (param $sig i32) (param $msg i64) (param $key i32) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a regular pointer to the buffer
  containing the 64-byte signature.
  
  \item \tmverbatim{msg}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the message that is to be verified.
  
  \item \tmverbatim{key}: a regular pointer to the buffer containing the
  32-byte public key.
  
  \item \tmverbatim{return}: a i32 integer value equal to \tmverbatim{1} if
  the signature is valid or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_secp256k1\_ecdsa\_recover}}

Verify and recover a SECP256k1 ECDSA signature.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_secp256k1_ecdsa_recover_version_1
  (param $sig i32) (param $msg i32) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a regular pointer to the buffer
  containing the 65-byte signature in RSV format. V should be either
  \tmverbatim{0/1} or \tmverbatim{27/28}.
  
  \item \tmverbatim{msg}: a regular pointer to the buffer containing the
  32-byte Blake2 hash of the message.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined in Definition \ref{defn-result-type}. On success it contains the
  64-byte recovered public key or an error type as defined in Definition
  \ref{defn-ecdsa-verify-error} on failure.
\end{itemize}

\subsection{\tmverbatim{ext\_crypto\_secp256k1\_ecdsa\_recover\_compressed}}

Verify and recover a SECP256k1 ECDSA signature.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_crypto_secp256k1_ecdsa_recover_compressed_version_1
  (param $sig i32) (param $msg i32) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{sig}: a regular pointer to the buffer
  containing the 65-byte signature in RSV format. V should be either
  \tmverbatim{0/1} or \tmverbatim{27/28}.
  
  \item \tmverbatim{msg}: a regular pointer to the buffer containing the
  32-byte Blake2 hash of the message.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined in Definiton \ref{defn-result-type}. On success it contains the
  33-byte recovered public key in compressed form on success or an error type
  as defined in Definition \ref{defn-ecdsa-verify-error} on failure.
\end{itemize}

\section{Hashing}

Interface that provides functions for hashing with different algorithms.

\subsection{\tmverbatim{ext\_hashing\_keccak\_256}}

Conducts a 256-bit Keccak hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_hashing_keccak_256_version_1
  (param $data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a reglar pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_sha2\_256}}

Conducts a 256-bit Sha2 hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_hashing_sha2_256_version_1
  (param $data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_blake2\_128}}

Conducts a 128-bit Blake2 hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_hashing_blake2_128_version_1
  (param $data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  128-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_blake2\_256}}

Conducts a 256-bit Blake2 hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_hashing_blake2_256_version_1
  (param $data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_twox\_64}}

Conducts a 64-bit xxHash hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_hashing_twox_64_version_1
  (param $data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  64-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_twox\_128}}

Conducts a 128-bit xxHash hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_hashing_twox_128_version_1
  (param $data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  128-bit hash result.
\end{itemize}

\subsection{\tmverbatim{ext\_hashing\_twox\_256}}

Conducts a 256-bit xxHash hash.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_hashing_twox_256_version_1
  (param $data i64) (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item {\tmstrong{}}\tmverbatim{data}: a pointer-size as defined in
  Definition \ref{defn-runtime-pointer} indicating the data to be hashed.
  
  \item \tmverbatim{return}: a regular pointer to the buffer containing the
  256-bit hash result.
\end{itemize}

\section{Offchain}

The Offchain Workers allow the execution of long-running and possibly
non-deterministic tasks (e.g. web requests, encryption/decryption and signing
of data, random number generation, CPU-intensive computations,
enumeration/aggregation of on-chain data, etc.) which could otherwise require
longer than the block execution time. Offchain Workers have their own
execution environment. This separation of concerns is to make sure that the
block production is not impacted by the long-running tasks.

\

All data and results generated by Offchain workers are unique per node and
nondeterministic. Information can be propagated to other nodes by submitting a
transaction that should be included in the next block. As Offchain workers
runs on their own execution environment they have access to their own separate
storage. There are two different types of storage available which are defined
in Definitions F.1 and F.2.

\begin{definition}
  \label{defn-persistent-storage}{\tmstrong{Persistent storage}} is
  non-revertible and not fork-aware. It means that any value set by the
  offchain worker is persisted even if that block (at which the worker is
  called) is reverted as non-canonical (meaning that the block was surpassed
  by a longer chain). The value is available for the worker that is re-run at
  the new (different block with the same block number) and future blocks. This
  storage can be used by offchain workers to handle forks and coordinate
  offchain workers running on different forks.
\end{definition}

\begin{definition}
  \label{defn-local-storage}{\tmstrong{Local storage}} is revertible and
  fork-aware. It means that any value set by the offchain worker triggered at
  a certain block is reverted if that block is reverted as non-canonical. The
  value is NOT available for the worker that is re-run at the next or any
  future blocks.
\end{definition}

\begin{definition}
  \label{defn-http-status-codes}{\tmstrong{HTTP status codes}} that can get
  returned by certain Offchain HTTP functions.
  \begin{itemizedot}
    \item \tmverbatim{0}: the specified request identifier is invalid.
  \end{itemizedot}
  \begin{itemizedot}
    \item \tmverbatim{10}: the deadline for the started request was reached.
  \end{itemizedot}
  \begin{itemizedot}
    \item \tmverbatim{20}: an error has occurred during the request, e.g. a
    timeout or the remote server has closed the connection. On returning this
    error code, the request is considered destroyed and must be reconstructed
    again.
  \end{itemizedot}
  \begin{itemizedot}
    \item \tmverbatim{100-999}: the request has finished with the given HTTP
    status code.
  \end{itemizedot}
\end{definition}

\begin{definition}
  \label{defn-http-error}{\tmstrong{HTTP error}} is a varying data type as
  defined in Definition \ref{defn-varrying-data-type} and specifies the error
  types of certain HTTP functions. Following values are possible:
  
  \begin{table}[h]
    \begin{tabular}{ll}
      {\tmstrong{Id}} & {\tmstrong{Description}}\\
      0 & The deadline was reached\\
      1 & There was an IO error while processing the request\\
      2 & The ID of the request is invalid
    \end{tabular}
    \caption{Table of possible HTTP error types}
  \end{table}
\end{definition}

\subsection{\tmverbatim{ext\_offchain\_is\_validator}}

Verifies if the local node is a potential validator. Even if this function
returns true, it does not mean that any keys are configured or that the
validator is registered in the chain.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_is_validator_version_1 (return i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{return}: a i32 integer which is equal to \tmverbatim{1} if
  the local node is a potential validator or a integer equal to \tmverbatim{0}
  if it is not.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_submit\_transaction}}

Given an extrinsic as a SALE encoded byte array, the system decodes the byte
array and submits the extrinsic in the inherent pool as an extrinsic to be
included in the next produced block.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_submit_transaction_version_1 (param $data i64) (return i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the byte array storing the encoded
  extrinsic.
  
  \item \tmverbatim{return}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined in Definition \ref{defn-result-type}. Neither on success or
  failure is there any additional data provided.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_network\_state}}

Returns the SCALE encoded, opaque information about the local node's network
state. This information is fetched by calling into \tmverbatim{libp2p}, which
{\tmem{might}} include the \tmverbatim{PeerId} and possible
\tmverbatim{Multiaddress(-es)} by which the node is publicly known by. Those
values are unique and have to be known by the node individually. Due to its
opaque nature, it's unknown whether that information is available prior to
execution.

{\tmstrong{\subsubsection{Version 1 - Prototype}}}
\begin{alltt}
(func $ext_offchain_network_state_version_1 (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined in Definition \ref{defn-result-type}. On success it contains the
  SCALE encoded network state. This includes none or one \tmverbatim{PeerId}
  followed by none, one or more IPv4 or IPv6 \tmverbatim{Multiaddress(-es)} by
  which the node is publicly known by. On failure no additional data is
  provided.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_timestamp}}

Returns current timestamp.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_timestamp_version_1 (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result}: an i64 integer indicating the current UNIX
  timestamp as defined in Definition \ref{defn-unix-time}.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_sleep\_until}}

Pause the execution until `deadline` is reached.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_sleep_until_version_1 (param $deadline i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{deadline}: an i64 integer specifying the UNIX timestamp as
  defined in Definition \ref{defn-unix-time}.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_random\_seed}}

Generates a random seed. This is a truly random non deterministic seed
generated by the host environment.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_random_seed_version_1 (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result}: a pointer to the buffer containing the 32-byte
  seed.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_local\_storage\_set}}

Sets a value in the local storage. This storage is not part of the consensus,
it's only accessible by the offchain worker tasks running on the same machine
and is persisted between runs.

{\tmstrong{\subsubsection{Version 1 - Prototype}}}
\begin{alltt}
(func $ext_offchain_local_storage_set_version_1
  (param $kind i32) (param $key i64) (param $value i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{kind}: an i32 integer indicating the storage kind. A value
  equal to 1 is used for a persistent storage as defined in Definition
  \ref{defn-offchain-persistent-storage} and a value equal to 2 for local
  storage as defined in Definition \ref{defn-offchain-local-storage}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the value.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_local\_storage\_compare\_and\_set}}

Sets a new value in the local storage if the condition matches the current
value.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_local_storage_compare_and_set_version_1
  (param $kind i32) (param $key i64) (param $old_value i64) (param $new_value i64)
  (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{kind}: an i32 integer indicating the storage kind. A value
  equal to 1 is used for a persistent storage as defined in Definition
  \ref{defn-offchain-persistent-storage} and a value equal to 2 for local
  storage as defined in Definition \ref{defn-offchain-local-storage}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{old\_value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the old key.
  
  \item \tmverbatim{new\_value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the new value.
  
  \item \tmverbatim{result}: an i32 integer equal to \tmverbatim{1} if the new
  value has been set or a value equal to \tmverbatim{0} if otherwise.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_local\_storage\_get}}

Gets a value from the local storage.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_local_storage_get_version_1
  (param $kind i32) (param $key i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{kind}: an i32 integer indicating the storage kind. A value
  equal to 1 is used for a persistent storage as defined in Definition
  \ref{defn-offchain-persistent-storage} and a value equal to 2 for local
  storage as defined in Definition \ref{defn-offchain-local-storage}.
  
  \item \tmverbatim{key}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the key.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the value or the
  corresponding key.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_http\_request\_start}}

Initiates a HTTP request given by the HTTP method and the URL. Returns the id
of a newly started request.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_http_request_start_version_1
  (param $method i64) (param $uri i64) (param $meta i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{method}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the HTTP method. Possible values are
  \tmverbatim{``GET''} and \tmverbatim{``POST''}.
  
  \item \tmverbatim{urli}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the URI.
  
  \item \tmverbatim{meta}: a future-reserved field containing additional,
  SCALE encoded parameters. Currently, an empty array should be passed.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined in Definition \ref{defn-result-type} containing the i16 ID of the
  newly started request. On failure no additionally data is provided.
\end{itemize}

\subsection{\tmverbatim{ext\_offchain\_http\_request\_add\_header}}

Append header to the request. Returns an error if the request identifier is
invalid, \tmverbatim{http\_response\_wait} has already been called on the
specified request identifier, the deadline is reached or an I/O error has
happened (e.g. the remote has closed the connection).

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_http_request_add_header_version_1
  (param $request_id i32) (param $name i64) (param $value i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{name}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the HTTP header name.
  
  \item \tmverbatim{value}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the HTTP header value.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined in Definition \ref{defn-result-type}. Neither on success or
  failure is there any additional data provided.
\end{itemize}

\subsection{\tmverbatim{ext\_http\_request\_write\_body}}

Writes a chunk of the request body. Returns a non-zero value in case the
deadline is reached or the chunk could not be written.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_http_request_write_body_version_1
  (param $request_id i32) (param $chunk i64) (param $deadline i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{chunk}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the chunk of bytes. Writing an empty
  chunk finalizes the request.
  
  \item \tmverbatim{deadline}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the UNIX
  timestamp as defined in Definition \ref{defn-unix-time}. Passing
  \tmverbatim{None} blocks indefinitely.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined Definition \ref{defn-result-type}. On success, no additional data
  is provided. On error it contains the HTTP error type as defined in
  Definition \ref{defn-http-error}.
\end{itemize}

\subsection{\tmverbatim{ext\_http\_response\_wait}}

Returns an array of request statuses (the length is the same as IDs). Note
that if deadline is not provided the method will block indefinitely, otherwise
unready responses will produce \tmverbatim{DeadlineReached} status.

{\tmstrong{\subsubsection{Version 1- Prototype}}}
\begin{alltt}
(func $ext_offchain_http_response_wait_version_1
  (param $ids i64) (param $deadline i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{ids}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded array of started
  request IDs.
  
  \item \tmverbatim{deadline}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the UNIX
  timestamp as defined in Definition 1.10. Passing \tmverbatim{None} blocks
  indefinitely.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded array of request
  statuses as defined in Definition \ref{defn-http-status-codes}.
\end{itemize}

\subsection{\tmverbatim{ext\_http\_response\_headers}}

Read all HTTP response headers. Returns an array of key/value pairs. Response
headers must be read before the response body.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_http_response_headers_version_1
  (param $request_id i32) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating a SCALE encoded array of key/value
  pairs.
\end{itemize}

\subsection{\tmverbatim{ext\_http\_response\_read\_body}}

Reads a chunk of body response to the given buffer. Returns the number of
bytes written or an error in case a deadline is reached or the server closed
the connection. If \tmverbatim{0} is returned it means that the response has
been fully consumed and the \tmverbatim{request\_id} is now invalid. This
implies that response headers must be read before draining the body.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_offchain_http_response_read_body_version_1
  (param $request_id i32) (param $buffer i64) (param $deadline i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{buffer}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the buffer where the body gets written
  to.
  
  \item \tmverbatim{deadline}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the UNIX
  timestamp as defined in Definition \ref{defn-unix-time}. Passing
  \tmverbatim{None} will block indefinitely.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Result}
  as defined in Definition \ref{defn-result-type}. On success it contains an
  i32 integer specifying the number of bytes written or a HTTP error type as
  defined in Definition \ref{defn-http-error} on faiure.
\end{itemize}

\section{Trie}

Interface that provides trie related functionality.

\subsection{\tmverbatim{blake2\_256\_root}}

Conducts a 256-bit Blake2 trie root formed from the iterated items.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_trie_blake2_256_root_version_1
  (param $data i64) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the iterated items from which the trie
  root gets formed. The items consist of a SCALE encoded array containing
  arbitrary key/value pairs.
  
  \item \tmverbatim{result}: a regular pointer to the buffer containing the
  256-bit trie root result.
\end{itemize}

\subsection{\tmverbatim{blake2\_256\_ordered\_root}}

Conducts a 256-bit Blake2 trie root formed from the enumerated items.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_trie_blake2_256_ordered_root_version_1
  (param $data i64) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the enumerated items from which the
  trie root gets formed. The items consist of a SCALE encoded array containing
  only values, where the corresponding key of each value is the index of the
  item in the array, starting at 0. The keys are little-endian, fixed-size
  integers.
  
  \item \tmverbatim{result}: a regular pointer to the buffer containing the
  256-bit trie root result.
\end{itemize}

\section{miscellaneous}

Interface that provides miscellaneous functions for communicating between the
runtime and the node.

\subsection{\tmverbatim{chain\_id}}

Returns the current relay chain identifier.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_misc_chain_id_version_1 (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result}: the current relay chain identifier.
\end{itemize}

\subsection{\tmverbatim{print\_num}}

Print a number.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_misc_print_num_version_1 (param $value i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{value}: the number to be printed.
\end{itemize}

\subsection{\tmverbatim{print\_utf8}}

Print a valid \tmverbatim{UTF8} buffer.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_misc_print_utf8_version_1 (param $data i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the valid \tmverbatim{UTF8} buffer to
  be printed.
\end{itemize}

\subsection{\tmverbatim{print\_hex}}

Print any buffer in hexadecimal representation.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_misc_print_hex_version_1 (param $data i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the buffer to be printed.
\end{itemize}

\subsection{\tmverbatim{runtime\_version}}

Extract the Runtime version of the given Wasm blob by calling
\tmverbatim{Core\_version} as defined in Definition
\ref{defn-rt-core-version}. Returns the SCALE encoded runtime version or
\tmverbatim{None} as defined in Definition \ref{defn-option-type} if the call
fails. This function gets primarily used when upgrading Runtimes.

\

{\tmstrong{Warning}}: Calling this function is very expensive and should only
be done very occasionally. For getting the runtime version, it requires
instantiating the Wasm blob as described in Section
\ref{sect-loading-runtime-code} and calling a function in this blob.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_misc_runtime_version_version_1 (param $data i64) (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the Wasm blob.
  
  \item \tmverbatim{result}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the SCALE encoded \tmverbatim{Option}
  as defined in Definition \ref{defn-option-type} containing the Runtime
  version of the given Wasm blob.
\end{itemize}

\section{Allocator}

Provides functionality for calling into the memory allocator.

\subsection{\tmverbatim{malloc}}

Allocates the given number of bytes and returns the pointer to that memory
location.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_allocator_malloc_version_1 (param $size i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{size}: the size of the buffer to be allocated.
  
  \item \tmverbatim{result}: a regular pointer to the allocated buffer.
\end{itemize}

\subsection{\tmverbatim{free}}

Free the given pointer.

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_allocator_free_version_1 (param $ptr i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{ptr}: a regular pointer to the memory buffer to be freed.
\end{itemize}

\section{Logging}

Interface that provides functions for logging from within the runtime.

\begin{definition}
  \label{defn-logging-log-level}{\tmstrong{Log Level}} is a varying data type
  as defined in Definition \ref{defn-varrying-data-type} and implies the
  emergency of the log. Possible levels and it's identifiers are defined in
  the following table.
  
  \begin{table}[h]
    \begin{tabular}{ll}
      {\tmstrong{Id}} & {\tmstrong{Level}} \\
      \hline
      0 & Error = 1\\
      1 & Warn = 2\\
      2 & Info = 3\\
      3 & Debug = 4\\
      4 & Trace = 5
    \end{tabular}
    \caption{Log Levels for the logging interface}
  \end{table}
\end{definition}

\subsection{\tmverbatim{log}}

Request to print a log message on the host. Note that this will be only
displayed if the host is enabled to display log messages with given level and
target.

\

\subsubsection{Version 1 - Prototype}

\begin{alltt}
(func $ext_logging_log_version_1
  (param $level i32) (param $target i64) (param $message i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{level}: the log level as defined in Definition
  \ref{defn-logging-log-level}.
  
  \item \tmverbatim{target}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the string which contains the path,
  module or location from where the log was executed.
  
  \item \tmverbatim{message}: a pointer-size as defined in Definition
  \ref{defn-runtime-pointer} indicating the log message.
\end{itemize}

\chapter{Legacy Runtime Environment API\label{sect-re-api}}

\

The Legacy Runtime Environments APIs were exceeded and replaces by the
current API as described in Appendix \ref{appendix-e}. Those legacy functions
are only required for executing Runtimes prior the official Polkadot Runtime,
such as the Kusama test network.

\

{\tmstrong{Note}}: This section will be removed in the future.

\section{Storage}

\subsection{\tmverbatim{ext\_set\_storage}}\label{sect-set-storage}

Sets the value of a specific key in the state storage.

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_storage
  (param $key_data i32) (param $key_len i32) (param $value_data i32)                           (param $value_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key}: a pointer indicating the buffer containing the key.
  
  \item \tmverbatim{key\_len}: the key length in bytes.
  
  \item \tmverbatim{value}: a pointer indicating the buffer containing the
  value to be stored under the key.
  
  \item \tmverbatim{value\_len}: the length of the value buffer in bytes.
\end{itemize}

\subsection{\tmverbatim{ext\_storage\_root}}

Retrieves the root of the state storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_storage_root
  (param $result_ptr i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result\_ptr}: a memory address pointing at a byte array
  which contains the root of the state storage after the function concludes.
\end{itemize}

\subsection{\tmverbatim{ext\_blake2\_256\_enumerated\_trie\_root}}

Given an array of byte arrays, it arranges them in a Merkle trie, defined
in\tmverbatim{{\tmem{{\tmstrong{}}}}} Section \ref{sect-merkl-proof}, where
the key under which the values are stored is the 0-based index of that value
in the array. It computes and returns the root hash of the constructed trie.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_blake2_256_enumerated_trie_root
      (param $values_data i32) (param $lens_data i32) (param $lens_len i32) 
      (param $result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{values\_data}: a memory address pointing at the buffer
  containing the array where byte arrays are stored consecutively.
  
  \item \tmverbatim{lens\_data}: an array of \tmverbatim{i32} elements each
  stores the length of each byte array stored in \tmverbatim{value\_data}.
  
  \item \tmverbatim{len}s\_len: the number of \tmverbatim{i32} elements in
  \tmverbatim{lens\_data}.
  
  \item \tmverbatim{result}: a memory address pointing at the beginning of a
  32-byte byte array containing the root of the Merkle trie corresponding to
  elements of \tmverbatim{values\_data}.
\end{itemize}

\subsection{\tmverbatim{ext\_clear\_prefix}}

Given a byte array, this function removes all storage entries whose key
matches the prefix specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_clear_prefix
      (param $prefix_data i32) (param $prefix_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{prefix\_data}: a memory address pointing at the buffer
  containing the byte array containing the prefix.
  
  \item \tmverbatim{prefix\_len}: the length of the byte array in number of
  bytes.
\end{itemize}

\subsection{\tmverbatim{}\tmverbatim{ext\_clear\_storage}}

Given a byte array, this function removes the storage entry whose key is
specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_clear_storage
      (param $key_data i32) (param $key_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
\end{itemize}

\subsection{\tmverbatim{ext\_exists\_storage}}

Given a byte array, this function checks if the storage entry corresponding to
the key specified in the array exists.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_exists_storage
      (param $key_data i32) (param $key_len i32) (result i32)
    )
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{result}: An \tmverbatim{i32} integer which is equal to 1
  verifies if an entry with the given key exists in the storage or 0 if the
  key storage does not contain an entry with the given key.
\end{itemize}

\subsection{\tmverbatim{ext\_get\_allocated\_storage}}

Given a byte array, this function allocates a large enough buffer in the
memory and retrieves the value stored under the key that is specified in the
array. Then, it stores it in the allocated buffer if the entry exists in the
storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $get_allocated_storage
      (param $key_data i32) (param $key_len i32) (param $written_out i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer
  containing the byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{written\_out}: the function stores the length of the
  retrieved value in number of bytes if the enty exists. If the entry does not
  exist, it returns $2^{32} - 1$.
  
  \item \tmverbatim{result}: A pointer to the buffer in which the function
  allocates and stores the value corresponding to the given key if such an
  entry exist; otherwise it is equal to 0.
\end{itemize}

\subsection{\tmverbatim{ext\_get\_storage\_into}}

Given a byte array, this function retrieves the value stored under the key
specified in the array and stores the specified chunk starting at the offset
into the provided buffer, if the entry exists in the storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_get_storage_into 
      (param $key_data i32) (param $key_len i32) (param $value_data i32)
      (param $value_len i32) (param $value_offset i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer of the
  byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{value\_data}: a pointer to the buffer in which the
  function stores the chunk of the value it retrieves.
  
  \item \tmverbatim{value\_len}: the (maximum) length of the chunk in bytes
  the function will read of the value and will store in the
  \tmverbatim{value\_data} buffer.
  
  \item \tmverbatim{value\_offset}: the offset of the chunk where the function
  should start storing the value in the provided buffer, i.e. the number of
  bytes the functions should skip from the retrieved value before storing the
  data in the \tmverbatim{value\_data} in number of bytes.
  
  \item \tmverbatim{result}: The number of bytes the function writes in
  \tmverbatim{value\_data} if the value exists or $2^{32} - 1$ if the entry
  does not exist under the specified key.
\end{itemize}

\subsection{\tmverbatim{ext\_set\_child\_storage}}

Sets the value of a specific key in the child state storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_set_child_storage
  (param $storage_key_data i32) (param $storage_key_len i32) (param $key_data i32)
  (param $key_len i32) (param $value_data i32) (param $value_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{storage\_key\_data}: a memory address pointing at the
  buffer of the byte array containing the child storage key. This key
  {\tmstrong{must}} be prefixed with \begin{tmcode}
  \tmverbatim{{\code*{:child\_storage:default:}}}
  \end{tmcode}
  
  \item \tmverbatim{storage\_key\_len}: the length of the child storage key
  byte array in number of bytes.
  
  \item \tmverbatim{key}: a pointer indicating the buffer containing the key.
  
  \item \tmverbatim{key\_len}: the key length in bytes.
  
  \item \tmverbatim{value}: a pointer indicating the buffer containing the
  value to be stored under the key.
  
  \item \tmverbatim{value\_len}: the length of the value buffer in bytes.
\end{itemize}

\subsection{\tmverbatim{ext\_clear\_child\_storage}}

Given a byte array, this function removes the child storage entry whose key is
specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_clear_child_storage
      (param $storage_key_data i32) (param $storage_key_len i32)
      (param $key_data i32) (param $key_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{storage\_key\_data}: a memory address pointing at the
  buffer of the byte array containing the child storage key.
  
  \item \tmverbatim{storage\_key\_len}: the length of the child storage key
  byte array in number of bytes.
  
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer of the
  byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the key byte array in number of
  bytes.
\end{itemize}

\subsection{\tmverbatim{ext\_exists\_child\_storage}}

Given a byte array, this function checks if the child storage entry
corresponding to the key specified in the array exists.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_exists_child_storage
      (param $storage_key_data i32) (param $storage_key_len i32)
      (param $key_data i32) (param $key_len i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{storage\_key\_data}: a memory address pointing at the
  buffer of the byte array containing the child storage key.
  
  \item \tmverbatim{storage\_key\_len}: the length of the child storage key
  byte array in number of bytes.
  
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer of the
  byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the key byte array in number of
  bytes.
  
  \item \tmverbatim{result}: an i32 integer which is equal to 1 verifies if an
  entry with the given key exists in the child storage or 0 if the child
  storage does not contain an entry with the given key.
\end{itemize}

\subsection{\tmverbatim{ext\_get\_allocated\_child\_storage}}

Given a byte array, this function allocates a large enough buffer in the
memory and retrieves the child value stored under the key that is specified in
the array. Then, it stores in in the allocated buffer if the entry exists in
the child storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_get_allocated_child_storage
      (param $storage_key_data i32) (param $storage_key_len i32) (param $key_data i32)             (param $key_len i32) (param $written_out) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{storage\_key\_data}: a memory address pointing at the
  buffer of the byte array containing the child storage key.
  
  \item \tmverbatim{storage\_key\_len}: the length of the child storage key
  byte array in number of bytes.
  
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer of the
  byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the key byte array in number of
  bytes.
  
  \item \tmverbatim{written\_out}: the function stores the length of the
  retrieved value in number of bytes if the enty exists. If the entry does not
  exist, it stores $2^{32} - 1$.
  
  \item \tmverbatim{result}: A pointer to the buffer in which the function
  allocates and stores the value corresponding to the given key if such an
  entry exist; otherwise it is equal to 0.
\end{itemize}

\subsection{\tmverbatim{ext\_get\_child\_storage\_into}}

Given a byte array, this function retrieves the child value stored under the
key specified in the array and stores the specified chunk starting the offset
into the provided buffer, if the entry exists in the storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_get_child_storage_into
      (param $storage_key_data i32) (param $storage_key_len i32)
      (param $key_data i32) (param $key_len i32) (param $value_data i32)
      (param $value_len i32) (param $value_offset i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{storage\_key\_data}: a memory address pointing at the
  buffer of the byte array containing the child storage key.
  
  \item \tmverbatim{storage\_key\_len}: the length of the child storage key
  byte array in number of bytes.
  
  \item \tmverbatim{key\_data}: a memory address pointing at the buffer of the
  byte array containing the key value.
  
  \item \tmverbatim{key\_len}: the length of the byte array in number of
  bytes.
  
  \item \tmverbatim{value\_data}: a pointer to the buffer in which the
  function stores the chunk of the value it retrieves.
  
  \item \tmverbatim{value\_len}: the (maximum) length of the chunk in bytes
  the function will read of the value and will store in the
  \tmverbatim{value\_data} buffer.
  
  \item \tmverbatim{value\_offset}: the offset of the chunk where the function
  should start storing the value in the provided buffer, i.e. the number of
  bytes the functions should skip from the retrieved value before storing the
  data in the \tmverbatim{value\_data} in number of bytes.
  
  \item \tmverbatim{result}: The number of bytes the function writes in
  \tmverbatim{value\_data} if the value exists or $2^{32} - 1$ if the entry
  does not exist under the specified key.
\end{itemize}

\subsection{\tmverbatim{ext\_kill\_child\_storage}}

Given a byte array, this function removes all entries of the child storage
whose child storage key is specified in the array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_kill_child_storage
      (param $storage_key_data i32) (param $storage_key_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{storage\_key\_data}: a memory address pointing at the
  buffer of the byte array containing the child storage key.
  
  \item \tmverbatim{storage\_key\_len}: the length of the child storage key
  byte array in number of bytes.
\end{itemize}

\subsection{Memory}

\subsubsection{\tmverbatim{ext\_malloc}}

Allocates memory of a requested size in the heap.

\

{\tmstrong{Prototype}}:
\begin{alltt}
(func $ext_malloc
  (param $size i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{size:} the size of the buffer to be allocated in number of
  bytes. 
\end{itemize}


{\tmstrong{Result}}:
\begin{itemize}
  a memory address pointing at the beginning of the allocated buffer.
\end{itemize}

\subsubsection{\tmverbatim{ext\_free}}

Deallocates a previously allocated memory.

\

{\tmstrong{Prototype}}:
\begin{alltt}
(func $ext_free
      (param $addr i32))
\end{alltt}


{\tmstrong{Arguments:}}
\begin{itemize}
  \item \tmverbatim{addr}: a 32bit memory address pointing at the allocated
  memory.
\end{itemize}

\subsubsection{Input/Output}

\begin{itemize}
  \item \tmverbatim{ext\_print\_hex}
  
  \item \tmverbatim{ext\_print\_num}
  
  \item \tmverbatim{ext\_print\_utf8}
\end{itemize}

\subsection{Cryptograhpic Auxiliary Functions}

\subsubsection{\tmverbatim{ext\_blake2\_256}}

Computes the Blake2b 256bit hash of a given byte array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func (export "ext_blake2_256")
      (param $data i32) (param  $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  32-byte byte array contanining the Blake2b hash of the data.
\end{itemize}

\subsubsection{\tmverbatim{ext\_keccak\_256}}

Computes the Keccak-256 hash of a given byte array.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_keccak_256
      (param $data i32) (param $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  32-byte byte array contanining the Keccak-256 hash of the data.
\end{itemize}

\subsubsection{\tmverbatim{ext\_twox\_128}}

Computes the {\tmem{xxHash64}} algorithm (see {\cite{collet_extremely_2019}})
twice initiated with seeds 0 and 1 and applied on a given byte array and
outputs the concatenated result.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_twox_128
       (param $data i32) (param $len i32) (param $out i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a memory address pointing at the buffer containing
  the byte array to be hashed.
  
  \item \tmverbatim{len}: the length of the byte array in bytes.
  
  \item \tmverbatim{out}: a memory address pointing at the beginning of a
  16-byte byte array containing \ {\tmem{$\text{xxhash}
  64_0$}}(\tmverbatim{data})\textbar\textbar{\tmem{$\text{xxhash64}_1$}}(\tmverbatim{data})
  where {\tmem{$\text{xxhash} 64_i$}} is the xxhash64 function initiated with
  seed $i$ as a 64bit unsigned integer.
\end{itemize}

\subsubsection{\tmverbatim{ext\_ed25519\_verify}}

Given a message signed by the ED25519 signature algorithm alongside with its
signature and the allegedly signer public key, it verifies the validity of the
signature by the provided public key.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_ed25519_verify
      (param $msg_data i32) (param $msg_len i32) (param $sig_data i32)
      (param $pubkey_data i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{msg\_data}: a pointer to the buffer containing the message
  body.
  
  \item \tmverbatim{msg\_len}: an \tmverbatim{i32} integer indicating the size
  of the message buffer in bytes.
  
  \item \tmverbatim{sig\_data}: a pointer to the 64 byte memory buffer
  containing the ED25519 signature corresponding to the message.
  
  \item \tmverbatim{pubkey\_data}: a pointer to the 32 byte buffer containing
  the public key and corresponding to the secret key which has signed the
  message.
  
  \item \tmverbatim{result}: \ an in\tmverbatim{}teger value equal to 0
  indicating the validity of the signature or a nonzero value otherwise.
\end{itemize}

\subsubsection{\tmverbatim{ext\_sr25519\_verify}}

Given a message signed by the SR25519 signature algorithm alongside with its
signature and the allegedly signer public key, it verifies the validity of the
signature by the provided public key.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_sr25519_verify
      (param $msg_data i32) (param $msg_len i32) (param $sig_data i32)
      (param $pubkey_data i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{msg\_data}: a pointer to the buffer containing the message
  body.
  
  \item \tmverbatim{msg\_len}: an \tmverbatim{i32} integer indicating the size
  of the message buffer in bytes.
  
  \item \tmverbatim{sig\_data}: a pointer to the 64 byte memory buffer
  containing the SR25519 signature corresponding to the message.
  
  \item \tmverbatim{pubkey\_data}: a pointer to the 32 byte buffer containing
  the public key and corresponding to the secret key which has signed the
  message.
  
  \item \tmverbatim{result}: \ an in\tmverbatim{}teger value equal to 0
  indicating the validity of the signature or a nonzero value otherwise.
\end{itemize}

\subsubsection{To be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_twox\_256}
\end{itemize}

\subsection{Offchain Worker }

The Offchain Workers allow the execution of long-running and possibly
non-deterministic tasks (e.g. web requests, encryption/decryption and signing
of data, random number generation, CPU-intensive computations,
enumeration/aggregation of on-chain data, etc.) which could otherwise require
longer than the block execution time. Offchain Workers have their own
execution environment. This separation of concerns is to make sure that the
block production is not impacted by the long-running tasks.

\

All data and results generated by Offchain workers are unique per node and
nondeterministic. Information can be propagated to other nodes by submitting a
transaction that should be included in the next block. As Offchain workers
runs on their own execution environment they have access to their own separate
storage. There are two different types of storage available which are defined
in Definitions \ref{defn-offchain-persistent-storage} and
\ref{defn-offchain-local-storage}.

\begin{definition}
  \label{defn-offchain-persistent-storage}{\tmstrong{Persistent
  {\tmstrong{storage}}}} is non-revertible and not fork-aware. It means that
  any value set by the offchain worker is persisted even if that block (at
  which the worker is called) is reverted as non-canonical (meaning that the
  block was surpassed by a longer chain). The value is available for the
  worker that is re-run at the new (different block with the same block
  number) and future blocks. This storage can be used by offchain workers to
  handle forks and coordinate offchain workers running on different forks.
\end{definition}

\begin{definition}
  \label{defn-offchain-local-storage}{\tmstrong{Local storage}} is revertible
  and fork-aware. It means that any value set by the offchain worker triggered
  at a certain block is reverted if that block is reverted as non-canonical.
  The value is NOT available for the worker that is re-run at the next or any
  future blocks.
  
  \begin{definition}
    \label{defn-http-return-value}{\tmstrong{HTTP status codes}} that can get
    returned by certain Offchain HTTP functions.
    \begin{itemizedot}
      \item {\tmstrong{0}}: the specified request identifier is invalid.
      
      \item {\tmstrong{10}}: the deadline for the started request was reached.
      
      \item {\tmstrong{20}}: an error has occurred during the request, e.g. a
      timeout or the remote server has closed the connection. On returning
      this error code, the request is considered destroyed and must be
      reconstructed again.
      
      \item {\tmstrong{100}}..{\tmstrong{999}}: the request has finished with
      the given HTTP status code.
    \end{itemizedot}
  \end{definition}
  
  \ 
\end{definition}

\subsubsection{\tmverbatim{ext\_is\_validator}}

Returns if the local node is a potential validator. Even if this function
returns 1, it does not mean that any keys are configured and that the
validator is registered in the chain.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_is_validator
      (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result}: \ an i32 in\tmverbatim{}teger which is equal to 1
  if the local node is a potential validator or a equal to 0 if it is not.
\end{itemize}

\subsubsection{\tmverbatim{ext\_submit\_transaction}}

Given an extrinsic as a SCALE encoded byte array, the system decodes the byte
array and submits the extrinsic in the inherent pool as an extrinsic to be
included in the next produced block.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_submit_transaction
      (param $data i32) (param $len i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer to the buffer containing the byte array
  storing the encoded extrinsic.
  
  \item \tmverbatim{len}: an \tmverbatim{i32} integer indicating the size of
  the encoded extrinsic.
  
  \item \tmverbatim{result}: an in\tmverbatim{}teger value equal to 0
  indicates that the extrinsic is successfully added to the pool or a nonzero
  value otherwise.
\end{itemize}

\subsubsection{\tmverbatim{ext\_network\_state}}

Returns the SCALE encoded, opaque information about the local node's network
state. This information is fetched by calling into \tmverbatim{libp2p}, which
{\tmem{might}} include the \tmverbatim{PeerId} and possible
\tmverbatim{Multiaddress(-es)} by which the node is publicly known by. Those
values are unique and have to be known by the node individually. Due to its
opaque nature, it's unknown whether that information is available prior to
execution.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_network_state
      (param $written_out i32)(result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{written\_out}: a pointer to the 4-byte buffer where the
  size of the opaque network state gets written to.
  
  \item \tmverbatim{result}: a pointer to the buffer containing the SCALE
  encoded network state. This includes none or one \tmverbatim{PeerId}
  followed by none, one or more IPv4 or IPv6 \tmverbatim{Multiaddress(-es)} by
  which the node is publicly known by.
\end{itemize}

\subsubsection{\tmverbatim{ext\_timestamp}}

Returns current timestamp.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_timestamp
      (result i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{result}: an i64 integer indicating the current UNIX
  timestamp as defined in Definition \ref{defn-unix-time}.
\end{itemize}

\subsubsection{\tmverbatim{ext\_sleep\_until}}

Pause the execution until `deadline` is reached.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_sleep_until
      (param $deadline i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{deadline}: an i64 integer specifying the UNIX timestamp as
  defined in Definition \ref{defn-unix-time}.
\end{itemize}

\subsubsection{\tmverbatim{ext\_random\_seed}}

Generates a random seed. This is a truly random non deterministic seed
generated by the host environment.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_random_seed
      (param $seed_data i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{seed\_data}: a memory address pointing at the beginning of
  a 32-byte byte array containing the generated seed.
\end{itemize}

\subsubsection{\tmverbatim{ext\_local\_storage\_set}}

Sets a value in the local storage. This storage is not part of the consensus,
it's only accessible by the offchain worker tasks running on the same machine
and is persisted between runs.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_local_storage_set
      (param $kind i32) (param $key i32) (param $key_len i32)
      (param $value i32) (param $value_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{kind}: an i32 integer indicating the storage kind. A value
  equal to 1 is used for a persistent storage as defined in Definition
  \ref{defn-offchain-persistent-storage} and a value equal to 2 for local
  storage as defined in Definition \ref{defn-offchain-local-storage}.
  
  \item \tmverbatim{key}: a pointer to the buffer containing the key.
  
  \item \tmverbatim{key\_len}: an i32 integer indicating the size of the key.
  
  \item \tmverbatim{value}: a pointer to the buffer containg the value.
  
  \item \tmverbatim{value\_len}: an i32 integer indicating the size of the
  value.
\end{itemize}

\subsubsection{\tmverbatim{ext\_local\_storage\_compare\_and\_set}}

Sets a new value in the local storage if the condition matches the current
value.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_local_storage_compare_and_set 
      (param $kind i32) (param $key i32) (param $key_len i32)
      (param $old_value i32) (param $old_value_len) (param $new_value i32)
      (param $new_value_len) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{kind}: an i32 integer indicating the storage kind. A value
  equal to 1 is used for a persistent storage as defined in Definition
  \ref{defn-offchain-persistent-storage} and a value equal to 2 for local
  storage as defined in Definition \ref{defn-offchain-local-storage}.
  
  \item \tmverbatim{key}: a pointer to the buffer containing the key.
  
  \item \tmverbatim{key\_len}: an i32 integer indicating the size of the key.
  
  \item \tmverbatim{old\_value}: a pointer to the buffer containing the
  current value.
  
  \item \tmverbatim{old\_value\_len}: an i32 integer indicating the size of
  the current value.
  
  \item \tmverbatim{new\_value}: a pointer to the buffer containing the new
  value.
  
  \item \tmverbatim{new\_value\_len}: an i32 integer indicating the size of
  the new value.
  
  \item \tmverbatim{result}: an i32 integer equal to 0 if the new value has
  been set or a value equal to 1 if otherwise.
\end{itemize}

\subsubsection{\tmverbatim{ext\_local\_storage\_get}}

Gets a value from the local storage.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_local_storage_get
      (param $kind i32) (param $key i32) (param $key_len i32)
      (param $value_len i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{kind}: an i32 integer indicating the storage kind. A value
  equal to 1 is used for a persistent storage as defined in Definition
  \ref{defn-offchain-persistent-storage} and a value equal to 2 for local
  storage as defined in Definition \ref{defn-offchain-local-storage}.
  
  \item \tmverbatim{key}: a pointer to the buffer containing the key.
  
  \item \tmverbatim{key\_len}: an i32 integer indicating the size of the key.
  
  \item \tmverbatim{value\_len}: an i32 integer indicating the size of the
  value.
  
  \item \tmverbatim{result}: a pointer to the buffer in which the function
  allocates and stores the value corresponding to the given key if such an
  entry exist; otherwise it is equal to 0.
\end{itemize}

\subsubsection{\tmverbatim{ext\_http\_request\_start}}

Initiates a http request given by the HTTP method and the URL. Returns the id
of a newly started request.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_http_request_start
      (param $method i32) (param $method_len i32) (param $url i32)
      (param $url_len i32) (param $meta i32) (param $meta_len i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{method}: a pointer to the buffer containing the key.
  
  \item \tmverbatim{method\_len}: an i32 integer indicating the size of the
  method.
  
  \item \tmverbatim{url}: a pointer to the buffer containing the url.
  
  \item \tmverbatim{url\_len}: an i32 integer indicating the size of the url.
  
  \item \tmverbatim{meta}: a future-reserved field containing additional,
  SCALE encoded parameters.
  
  \item \tmverbatim{meta\_len}: an i32 integer indicating the size of the
  parameters.
  
  \item \tmverbatim{result}: an i32 integer indicating the ID of the newly
  started request.
\end{itemize}

\subsubsection{\tmverbatim{ext\_http\_request\_add\_header}}

Append header to the request. Returns an error if the request identifier is
invalid, \tmverbatim{http\_response\_wait} has already been called on the
specified request identifier, the deadline is reached or an I/O error has
happened (e.g. the remote has closed the connection).

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_http_request_add_header
      (param $request_id i32) (param $name i32) (param $name_len i32)
      (param $value i32) (param $value_len i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{name}: a pointer to the buffer containing the header name.
  
  \item \tmverbatim{name\_len}: an i32 integer indicating the size of the
  header name.
  
  \item \tmverbatim{value}: a pointer to the buffer containing the header
  value.
  
  \item \tmverbatim{value\_len}: an i32 integer indicating the size of the
  header value.
  
  \item \tmverbatim{result}: an i32 integer where the value equal to 0
  indicates if the header has been set or a value equal to 1 if otherwise.
\end{itemize}

\subsubsection{\tmverbatim{ext\_http\_request\_write\_body}}

Writes a chunk of the request body. Writing an empty chunk finalises the
request. Returns a non-zero value in case the deadline is reached or the chunk
could not be written.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_http_request_write_body
      (param $request_id i32) (param $chunk i32) (param $chunk_len i32)
      (param $deadline i64) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{chunk}: a pointer to the buffer containing the chunk.
  
  \item \tmverbatim{chunk\_len}: an i32 integer indicating the size of the
  chunk.
  
  \item \tmverbatim{deadline}: an i64 integer specifying the UNIX timestamp as
  defined in Definition \ref{defn-unix-time}. Passing '0' will block
  indefinitely.
  
  \item \tmverbatim{result}: an i32 integer where the value equal to 0
  indicates if the header has been set or a non-zero value if otherwise.
\end{itemize}

\subsubsection{\tmverbatim{ext\_http\_response\_wait}}

Blocks and waits for the responses for given requests. Returns an array of
request statuses (the size is the same as number of IDs).

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_http_response_wait
      (param $ids i32) (param $ids_len i32) (param $statuses i32)
      (param $deadline i64))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{ids}: a pointer to the buffer containing the started IDs.
  
  \item \tmverbatim{ids\_len}: an i32 integer indicating the size of IDs.
  
  \item \tmverbatim{statuses}: a pointer to the buffer where the request
  statuses get written to as defined in Definition
  \ref{defn-http-return-value}. The lenght is the same as the length of
  \tmverbatim{ids}.
  
  \item \tmverbatim{deadline}: an i64 integer indicating the UNIX timestamp as
  defined in Definition \ref{defn-unix-time}. Passing '0' as deadline will
  block indefinitely.
\end{itemize}

\subsubsection{\tmverbatim{ext\_http\_response\_headers}}

Read all response headers. Returns a vector of key/value pairs. Response
headers must be read before the response body.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_http_response_headers
      (param $request_id i32) (param $written_out i32) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{written\_out}: a pointer to the buffer where the size of
  the response headers gets written to.
  
  \item \tmverbatim{result}: a pointer to the buffer containing the response
  headers.
\end{itemize}

\subsubsection{\tmverbatim{ext\_http\_response\_read\_body}}

Reads a chunk of body response to the given buffer. Returns the number of
bytes written or an error in case a deadline is reached or the server closed
the connection. If `0' is returned it means that the response has been fully
consumed and the \tmverbatim{request\_id} is now invalid. This implies that
response headers must be read before draining the body.

\

{\tmstrong{Prototype:}}
\begin{alltt}
(func $ext_http_response_read_body
      (param $request_id i32) (param $buffer i32) (param $buffer_len)
      (param $deadline i64) (result i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{request\_id}: an i32 integer indicating the ID of the
  started request.
  
  \item \tmverbatim{buffer}: a pointer to the buffer where the body gets
  written to.
  
  \item \tmverbatim{buffer\_len}: an i32 integer indicating the size of the
  buffer.
  
  \item \tmverbatim{deadline}: an i64 integer indicating the UNIX timestamp as
  defined in Definition \ref{defn-unix-time}. Passing '0' will block
  indefinitely.
  
  \item \tmverbatim{result}: an i32 integer where the value equal to 0
  indicateds a fully consumed response or a non-zero value if otherwise.
\end{itemize}

\subsection{Sandboxing}

\subsubsection{To be Specced}

\begin{itemize}
  \item \tmverbatim{ext\_sandbox\_instance\_teardown}
  
  \item \tmverbatim{ext\_sandbox\_instantiate}
  
  \item \tmverbatim{ext\_sandbox\_invoke}
  
  \item \tmverbatim{ext\_sandbox\_memory\_get}
  
  \item \tmverbatim{ext\_sandbox\_memory\_new}
  
  \item \tmverbatim{ext\_sandbox\_memory\_set}
  
  \item \tmverbatim{ext\_sandbox\_memory\_teardown}
\end{itemize}

\subsection{Auxillary Debugging API}

\subsubsection{\tmverbatim{ext\_print\_hex}}

Prints out the content of the given buffer on the host's debugging console.
Each byte is represented as a two-digit hexadecimal number.

\

{\tmstrong{Prototype:}}
\begin{alltt}
    (func $ext_print_hex
      (param $data i32) (parm $len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{data}: a pointer to the buffer containing the data that
  needs to be printed.
  
  \item \tmverbatim{len}: an \tmverbatim{i32} integer indicating the size of
  the buffer containing the data in bytes.
\end{itemize}

\subsubsection{\tmverbatim{ext\_print\_utf8}}

Prints out the content of the given buffer on the host's debugging console.
The buffer content is interpreted as a UTF-8 string if it represents a valid
UTF-8 string, otherwise does nothing and returns.

{\tmstrong{Prototype:}}o
\begin{alltt}
    (func $ext_print_utf8
      (param $utf8_data i32) (param $utf8_len i32))
\end{alltt}


{\tmstrong{Arguments}}:
\begin{itemize}
  \item \tmverbatim{utf8\_data}: a pointer to the buffer containing the
  utf8-encoded string to be printed.
  
  \item \tmverbatim{utf8\_len}: an \tmverbatim{i32} integer indicating the
  size of the buffer containing the UTF-8 string in bytes.
\end{itemize}

\subsection{Misc}

\subsubsection{To be Specced}
\begin{itemizedot}
  \item \tmverbatim{ext\_chain\_id}
\end{itemizedot}
\tmverbatim{}\subsection{Block Production}

\section{Validation}

\

\chapter{Runtime Entries}\label{sect-runtime-entries}

\section{List of Runtime Entries}\label{sect-list-of-runtime-entries}

Polkadot RE assumes that at least the following functions are implemented in
the Runtime Wasm blob and have been exported as shown in Snippet
\ref{snippet-runtime-enteries}:

\tmfloat{h}{small}{figure}{\begin{tmcode}[cpp]
  (export "Core_version" (func $Core_version))
  (export "Core_execute_block" (func $Core_execute_block))
  (export "Core_initialize_block" (func $Core_initialize_block))
  (export "Metadata_metadata" (func $Metadata_metadata))
  (export "BlockBuilder_apply_extrinsic" (func $BlockBuilder_apply_extrinsic))
  (export "BlockBuilder_finalize_block" (func $BlockBuilder_finalize_block))
  (export "BlockBuilder_inherent_extrinsics" 
          (func $BlockBuilder_inherent_extrinsics))
  (export "BlockBuilder_check_inherents" (func $BlockBuilder_check_inherents))
  (export "BlockBuilder_random_seed" (func $BlockBuilder_random_seed))
  (export "TaggedTransactionQueue_validate_transaction" 
          (func $TaggedTransactionQueue_validate_transaction))
  (export "OffchainWorkerApi_offchain_worker" 
          (func $OffchainWorkerApi_offchain_worker))
  (export "ParachainHost_validators" (func $ParachainHost_validators))
  (export "ParachainHost_duty_roster" (func $ParachainHost_duty_roster))
  (export "ParachainHost_active_parachains" 
          (func $ParachainHost_active_parachains))
  (export "ParachainHost_parachain_status" (func $ParachainHost_parachain_status))
  (export "ParachainHost_parachain_code" (func $ParachainHost_parachain_code))
  (export "ParachainHost_ingress" (func $ParachainHost_ingress))
  (export "GrandpaApi_grandpa_pending_change" 
          (func $GrandpaApi_grandpa_pending_change))
  (export "GrandpaApi_grandpa_forced_change" 
          (func $GrandpaApi_grandpa_forced_change))
  (export "GrandpaApi_grandpa_authorities" (func $GrandpaApi_grandpa_authorities))
  (export "BabeApi_configuration" (func $BabeApi_configuration))
  (export "SessionKeys_generate_session_keys" 
          (func $SessionKeys_generate_session_keys))

\end{tmcode}}{\label{snippet-runtime-enteries}Snippet to export entries into
tho Wasm runtime module.}

The following sections describe the standard based on which Polkadot RE
communicates with each runtime entry.

\section{Argument Specification}

As a wasm functions, all runtime entries have the following prototype
signature:


\begin{alltt}
    (func $generic_runtime_entry
      (param $data i32) (parm $len i32) (reslut i64))
\end{alltt}


where \tmverbatim{data} points to the SCALE encoded paramaters sent to the
function and \tmverbatim{len} is the length of the data. \tmverbatim{result}
can similarly either point to the SCALE encoded data the function returns (See
Sections \ref{sect-runtime-send-args-to-runtime-enteries} and
\ref{sect-runtime-return-value}).

In this section, we describe the function of each of the entries alongside
with the details of the arguments and the return values for each one of these
enteries.

\subsection{\tmverbatim{Core\_version}}\label{defn-rt-core-version}

This entry receives no argument; it returns the version data encoded in ABI
format described in Section \ref{sect-runtime-return-value} containing the
following information:

\tmverbatim{}

\begin{center}
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    Name & Type & Description\\
    \hline
    \tmverbatim{spec\_name} & String & Runtime identifier\\
    \tmverbatim{impl\_name} & String & the name of the implementation (e.g.
    C++)\\
    \tmverbatim{authoring\_version} & UINT32 & the version of the authorship
    interface\\
    \tmverbatim{spec\_version} & UINT32 & the version of the Runtime
    specification\\
    \tmverbatim{impl\_version} & UINT32 & the v\tmverbatim{}ersion of the
    Runtime implementation\\
    \tmverbatim{apis} & ApisVec & List of supported AP\\
    \hline
  \end{tabular}}{Detail of the version data type returns from runtime
  \tmverbatim{version} function.}
\end{center}

\subsection{\tmverbatim{Core\_execute\_block}}\label{sect-core-execute-block}

Executes a full block by executing all exctrinsics included in it and update
the state accordingly. Additionally, some integrity checks are executed such
as validating if the parent hash is correct and that the transaction root
represents the transactions. Internally, this function performs an operation
similar to the process described in Algorithm \ref{algo-build-block}, by
calling \tmverbatim{Core\_initialize\_block},
\tmverbatim{BlockBuilder\_apply\_extrinsics} and
\tmverbatim{BlockBuilder\_finalize\_block}.

\

This function should be called when a fully complete block is available that
is not actively being built on, such as blocks received from other peers.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item The entry accepts the {\tmem{block data}} defined in Definition
  \ref{defn-block-data} as the only argument.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item A boolean value indicates if the execution was successful.
\end{itemizedot}

\subsection{\tmverbatim{Core\_initialize\_block}}

Sets up the environment required for building a new block as described in
Algorithm \ref{algo-build-block}.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item The block header of the new block as defined in
  \ref{defn-block-header}. The values {\tmstrong{$H_r$}}, {\tmstrong{$H_e$}}
  and {\tmstrong{$H_d$}} are left empty.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item None.
\end{itemizedot}
\subsection{\tmverbatim{hash\_and\_length}}\label{sect-rte-hash-and-length}

An auxilarry function which returns hash and encoding length of an extrinsics.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item A blob of an extrinsic.
\end{itemize}
\tmverbatim{}

{\tmstrong{Return}}:
\begin{itemizedot}
  \item Pair of Blake2Hash of the blob as element of $\mathbb{B}_{32}$ and its
  length as 64 bit integer.
\end{itemizedot}
\subsection{\tmverbatim{BabeApi\_configuration}}\label{sect-rte-babeapi-epoch}

This entry is called to obtain the current configuration of BABE consensus
protocol.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item None
\end{itemize}


{\tmstrong{Return}}:

A tuple containing configuration data used by the Babe consensus engine.

\begin{table}[h]
  \begin{tabular}{lll}
    \hline
    {\tmstrong{Name}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
    \hline
    SlotDuration & The slot duration in milliseconds. Currently, only the
    value provided & Unsigned 64bit\\
    & by this type at genesis will be used. Dynamic slot duration may be &
    integer\\
    & supported in the future. & \\
    \hline
    EpochLength & The duration of epochs in slots. & Unsigned 64bit\\
    &  & integer\\
    \hline
    Constant & A constant value that is used in the threshold calculation
    formula. & Tuple containing\\
    & Expressed as a rational where the first number of the tuple is the &
    two unsigned\\
    & numerator and the seconds is the denominator. The rational should &
    64bit integers\\
    & represent a value between 0 and 1. & \\
    \hline
    Genesis & The authority list for the genesis epoch as defined in
    Definition \ref{defn-authority-list}.  & Array of tuples\\
    Authorities &  & containing a 256-bit\\
    &  & byte array and a\\
    &  & unsigned 64bit\\
    &  & integer\\
    \hline
    Randomness & The randomness for the genesis epoch & 32-byte array\\
    \hline
    SecondarySlot & Whether this chain should run with secondary slots, which
    are & Boolean\\
    & assigned in a round-robin manner. & \\
    \hline
  \end{tabular}
  \caption{The tuple provided by {\tmstrong{BabeApi\_configuration}}.}
\end{table}

\subsection{\tmverbatim{GrandpaApi\_grandpa\_authorities}}\label{sect-rte-grandpa-auth}

This entry fetches the list of GRANDPA authorities according to the genesis
block and is used to initialize authority list defined in Definition
\ref{defn-authority-list}, at genisis. Any future authority changes get
tracked via Runtiem-to-consensus engine messages as described in Section
\ref{sect-consensus-message-digest}.

\subsection{\tmverbatim{TaggedTransactionQueue\_validate\_transaction}}\label{sect-rte-validate-transaction}

This entry is invoked against extrinsics submitted through the Transaction
network message \ref{sect-msg-transactions} and indicates if the submitted
blob represents a valid extrinsics applied to the specified block.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item UTX: A byte array that contains the transaction.
\end{itemize}


{\tmstrong{Return}}:

This function returns a \tmverbatim{Result} as defined in Definition
\ref{defn-result-type} which contains the type {\tmem{ValidTransaction}} as
defined in Definition \ref{defn-valid-transaction} on success and the type
{\tmem{TransactionValidityError}} as defined in Definition
\ref{defn-transaction-validity-error} on failure.

\begin{definition}
  \label{defn-valid-transaction}{\tmstrong{ValidTransaction}} is a tuple which
  contains information concerning a valid transaction.
  
  \
  
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    {\tmstrong{Name}} & {\tmstrong{Description}} & {\tmstrong{Type}}\\
    \hline
    Priority & Determines the ordering of two transactions that have &
    Unsigned 64bit\\
    & all their dependencies (required tags) satisfied. & integer\\
    \hline
    Requires & List of tags specifying extrinsics which should be applied  &
    Array containing\\
    & before the current exrinsics can be applied. & inner arrays\\
    \hline
    Provides & Informs Runtime of the extrinsics depending on the tags in &
    Array containing\\
    & the list that can be applied after current extrinsics are being
    applied. & inner arrays\\
    & Describes the minimum number of blocks for the validity to be correct &
    \\
    \hline
    Longevity & After this period, the transaction should be removed from the 
    & Unsigned 64bit\\
    & pool or revalidated. & integer\\
    \hline
    Propagate & A flag indicating if the transaction should be propagated to 
    & Boolean\\
    & other peers. & \\
    \hline
  \end{tabular}}{The tuple provided by
  \tmverbatim{TaggedTransactionQueue\_transaction\_validity}
  in the case the transaction is judged to be valid.}
\end{definition}

Note that if {\tmem{Propagate}} is set to \tmverbatim{false} the transaction
will still be considered for including in blocks that are authored on the
current node, but will never be sent to other peers.

\begin{definition}
  \label{defn-transaction-validity-error}{\tmstrong{TransactionValidityError}}
  is a varying data type as defined in Definition
  \ref{defn-varrying-data-type}, where following values are possible:
  
  \
  
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    \hline
    {\tmstrong{{\tmstrong{}}Id}} & {\tmstrong{Descri{\tmstrong{}}ption}} &
    {\tmstrong{Appended}}\\
    \hline
    0 & The transaction is invalid. & InvalidTransaction
    (\ref{defn-invalid-transaction})\\
    1 & The transaction validity can't be determined. & UnknownTransaction
    (\ref{defn-unknown-transaction})\\
    \hline
  \end{tabular}}{Type variation for the return value of
  \tmverbatim{TaggedTransactionQueue\_transaction\_validity}.}
  
  \begin{definition}
    \label{defn-invalid-transaction}{\tmstrong{InvalidTransaction}} is a
    varying data type as defined in Definition \ref{defn-varrying-data-type}
    which can get appended to TransactionValidityError and describes the
    invalid transaction in more precise detail. The following values are
    possible:
    
    \begin{table}[h]
      \begin{tabular}{lll}
        \hline
        {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Appended}}\\
        \hline
        0 & Call: The call of the transaction is not expected & \\
        1 & Payment: Inability to pay some fees (e.g. balance too low) & \\
        2 & Future: Transaction not yet valid (e.g. nonce too high) & \\
        3 & Stale: Transaction is outdated (e.g. nonce too low) & \\
        4 & BadProof: Bad transaction proof (e.g. bad signature) & \\
        5 & AncientBirthBlock: Transaction birth block is ancient. & \\
        6 & ExhaustsResources: Transaction would exhaus the resources of the
        current block & \\
        7 & Custom: Any other custom message not covered by this type.  & one
        byte\\
        \hline
      \end{tabular}
      \caption{Type variant whichs gets appended to Id 0 of
      {\tmstrong{TransactionValidityError}}.}
    \end{table}
  \end{definition}
  
  \begin{definition}
    \label{defn-unknown-transaction}{\tmstrong{UnknownTransacion}} is a
    varying data type as defined in Definition \ref{defn-varrying-data-type}
    which can get appended to TransactionValidityError and describes the
    unknown transaction validity in more precise detail. The following values
    are possible:
    
    \begin{table}[h]
      \begin{tabular}{lll}
        \hline
        {\tmstrong{Id}} & {\tmstrong{Description}} & {\tmstrong{Appended}}\\
        0 & CannotLookup: Could not lookup some info that is required for the
        transaction & \\
        1 & NoUnsignedValidator: No validator found for the given unsigned
        transaction. & \\
        2 & Custom: Any other custom message not covered by this type & one
        byte\\
        \hline
      \end{tabular}
      \caption{Type variant whichs gets appended to Id 1 of
      {\tmstrong{TransactionValidityError}}.}
    \end{table}
  \end{definition}
  
  \ 
\end{definition}

\subsection{\tmverbatim{BlockBuilder\_apply\_extrinsic}}

Apply the extrinsic outside of the block execution function. This doesn't
attempt to validate anything regarding the block, but it builds a list of
transaction hashes.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item An extrinisic.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item The result from the attempt to apply extrinsic. On success, it returns
  an array of zero length (one byte zero value). On failure, it either returns
  a Dispatch error or an Apply error. An Apply error uses identifiers to
  indicate the specific error type.
  
  \
  
  Dispatch error (\tmverbatim{0x0001} prefix) byte array, contains the
  following information:
  
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    {\tmstrong{Name}} & {\tmstrong{Type}} & {\tmstrong{Description}}\\
    module & unsigned 8 bit integer & Module index, matching the metadata
    module index\\
    error & unsigend 8 bit integer & Module specific error value
  \end{tabular}}{Data format of the Dispatch error type}
  
  \
  
  Apply error (\tmverbatim{0x01} prefix). A Validity error type contains
  additional data for specific error types.
  
  \tmfloat{h}{small}{table}{\begin{tabular}{lll}
    {\tmstrong{Identifier}} & {\tmstrong{Type}} & {\tmstrong{Description}}\\
    \tmverbatim{0x00} & NoPermission & General error to do wth the permissions
    of the sender\\
    \tmverbatim{0x01} & BadState & General error to do with the state of the
    system in general\\
    \tmverbatim{0x02} & Validity & Any error to do with the transaction
    validity\\
    \tmverbatim{0x020000} & Call & The call of the transaction is not
    expected\\
    \tmverbatim{0x020001} & Payment & Inability to pay fees (e.g. account
    balance too low)\\
    \tmverbatim{0x020002} & Future & Transaction not yet being valid (e.g.
    nonce too high)\\
    \tmverbatim{0x020003} & Stale & Transaction being outdated (e.g. nonce too
    low)\\
    \tmverbatim{0x020004} & BadProof & Invalid transaction proofs (e.g. bad
    signature)\\
    \tmverbatim{0x020005} & AncientBirthBlock & The transaction birth block is
    ancient\\
    \tmverbatim{0x020006} & ExhaustsResources & Would exhaust the resources of
    current block\\
    &  & the transaction might be valid\\
    \tmverbatim{0x020007} & Custom & Any other custom invalidity of unknown
    size\\
    \tmverbatim{0x020100} & CannotLookup & Could not lookup some information
    that is required\\
    &  & to validate the transaction\\
    \tmverbatim{0x020101} & NoUnsignedValidator & No validator found for the
    given unsigned transaction\\
    \tmverbatim{0x020102} & Custom & Any other custom invalidity of unknown
    size
  \end{tabular}}{Identifiers of the Apply error type}
\end{itemizedot}

\subsection{\tmverbatim{BlockBuilder\_inherent\_extrinsics}}

Generate inherent extrinsics. The inherent data will vary from chain to chain.

\

{\tmstrong{Arguments}}:
\begin{itemize}
  \item A {\tmname{Inherents-Data}} structure as defined in
  \ref{defn-inherent-data}.
\end{itemize}


{\tmstrong{Return}}:
\begin{itemizedot}
  \item An array of extrinisic where each extrinsic is a variable byte array.
\end{itemizedot}
\subsection{\tmverbatim{BlockBuilder\_finalize\_block}}\label{sect-blockbuilder-finalize-block}

Finalize the block - it is up to the caller to ensure that all header fields
are valid except for the state root.

\chapter*{Glossary}

\begin{theglossary}{gly}
  \listpart{}
\end{theglossary}

\begin{thebibliography}{}
  \ 
\end{thebibliography}

\printindex

\end{document}
